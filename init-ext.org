#+TITLE: Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+LATEX_CLASS: jmeorgdoc

* Reworking Configuration

  I originally read a [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][post]] by Sebastian Wiesner regarding the use of
  =use-package= that got me curious enough to attempt to rework my Emacs
  configuration. I now attempt to utilize =use-package= for all of the
  packages I use. Check John Wiegley's [[https://github.com/jwiegley/use-package/][Github Page]] for more details.

  I previously used =Cask= and =Pallet= to manage all of my packages, which
  worked quite well, but did not address the configuration side of
  things.

  I have now moved away from these tools in favor of using =use-package= to
  manage all package installation and configuration.

* File Header

  Add some comments to the beginning of the generated elisp file.

  #+BEGIN_SRC emacs-lisp :padline no
    ;;; init-ext.el -- Automatically generated initialization file
    ;;;
    ;;; This file is generated based on the init-ext.org file.
    ;;; Please see that file for complete documentation.
    ;;;
    ;;; Commentary:
    ;;; See init-ext.org
    ;;;
    ;;; Code:
    ;;;
  #+END_SRC

* Early loading

  These items need to be setup early in the Emacs loading process.

** Prefer newer

   In an effort to reduce the risk of loading outdated byte code files, set
   =load-prefer-newer= to =t=. Starting with Emacs version 24.5,
   =load-prefer-newer= can prevent outdated byte code files from being
   loaded. However, there is still a possibility that a source file would
   not be re-compiled. =auto-compile= works to fill this gap.

   #+BEGIN_SRC emacs-lisp
     (setq load-prefer-newer t)
   #+END_SRC

** Auto compilation

   Ensure we are always using the latest code. =auto-compile= ensures that
   source files are recompiled if newer than their compiled form.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :demand t
      :ensure t
      :config
      (progn
        (auto-compile-on-load-mode)
        (auto-compile-on-save-mode)))
  #+END_SRC

* General Configuration
** Exec path

   Pull the exec path from our shell, this ensures all of the binaries we
   expect are available to us.

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :if (memq window-system '(mac ns))
       :ensure t
       :config
       (progn
         (when (string-match-p "/zsh$" (getenv "SHELL"))
           ;; use an non-interactive login shell to ensure
           ;; zsh path is loaded properly from .zprofile
           ;; which only loads with login shell.
           (setq exec-path-from-shell-arguments '("-l")))
         (exec-path-from-shell-initialize)))
   #+END_SRC

** Library Paths

   Everything is situated underneath =user-emacs-directory (~/.emacs.d)=

   This makes everything self-contained and easy to migrate to other
   environments.

   This section contains all of the path configurations that are not
   machine specific. A seperate directory =(~/.emacs-meta)= is configured
   for =Meta= information files (backups, temporary files, etc.)

*** Metafiles

    First, we need to define the  =metafiles-dir= values.

    #+BEGIN_SRC emacs-lisp
      (defvar metafiles-dir
        "~/.emacs-meta" "Custom location for metadata.")
    #+END_SRC

    As this may be the first time I am running in this environment, the
    =metafiles-dir= directory may not actually exist. We go ahead and
    create it if it doesn't.

    #+BEGIN_SRC emacs-lisp
      (unless (file-exists-p metafiles-dir)
        (make-directory metafiles-dir))
    #+END_SRC

*** Temporary directory

    I can now set the Emacs temporary directory to be within the
    =metafiles-dir=, again creating it if necessary.

    #+BEGIN_SRC emacs-lisp
      (setq temporary-file-directory (concat metafiles-dir "/tmp/"))
      (unless (file-exists-p temporary-file-directory)
        (make-directory temporary-file-directory))
    #+END_SRC


** Additional Paths

   I add the =user-emacs-directory= to the load path here to ensure we can
   pick up the additional configuration files.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat user-emacs-directory "/lisp"))
   #+END_SRC

   I also add all top-level subdirectories of =user-emacs-directory=.

   #+BEGIN_SRC emacs-lisp
     (let ((default-directory user-emacs-directory))
           (normal-top-level-add-subdirs-to-load-path))
   #+END_SRC

*** Paths for meta-information

    I set up variables for all paths needed for storing things in the
    =meta-information= directory. By consolidating them all in one place
    (and using the variables later), I have an easier time keeping track of
    them and maintaining them.

    | Variable         | Purpose                                                                                                   |
    |------------------+-----------------------------------------------------------------------------------------------------------|
    | =meta-config=    | Location of no-littering's etc directory                                                                  |
    | =meta-data=      | Location of no-littering's var directory                                                                  |
    | =meta-saveplace= | Name of the file that records the =save-place-alist=, which stores the location of point in visited files |
    | =meta-backup=    | Location for backup files                                                                                 |
    | =meta-bookmarks= | Bookmarks file.                                                                                           |
    | =meta-savehist=  | File used by =savehist= where minibuffer history is saved to and loaded                                   |
    | =meta-recent=    | File to save the recent list into                                                                         |
    | =meta-saves=     | Prefix to use for auto-save files                                                                         |
    | =meta-ido=       | File in which the =ido= state is saved between invocations                                                |
    | =meta-tramp=     | File used for =tramp= persistence                                                                         |

    #+BEGIN_SRC emacs-lisp
      (defvar meta-config (concat metafiles-dir "/etc/")
        "Location of etc directory for no-littering.")
      (defvar meta-data (concat metafiles-dir "/var/")
        "Location of var directory for no-littering.")
      (defvar meta-saveplace (concat metafiles-dir "/places")
        "Name of the file that records save-place-alist.")
      (defvar meta-bookmarks (concat metafiles-dir "/bookmarks")
        "Location for bookmarks file.")
      (defvar meta-savehist (concat metafiles-dir "/savehist")
        "File used by savehist where minibuffer history is saved to and loaded.")
      (defvar meta-recent (concat metafiles-dir "/recentf")
        "File to save the recent list into.")
      (defvar meta-saves (concat metafiles-dir "/auto-save-list/.saves-")
        "Prefix to use for auto-save files.")
      (defvar meta-ido (concat metafiles-dir "/ido.last")
        "File in which the ido state is saved between invocations.")
      (defvar meta-tramp (concat metafiles-dir "/tramp")
        "File used for tramp persistence.")
      (defvar meta-url (concat metafiles-dir "/url")
        "Directory for url files.")
    #+END_SRC

    Having set all of the known paths, we use the =no-littering= package to
    attempt to catch the rest.

    #+BEGIN_SRC emacs-lisp
      (use-package no-littering
        :ensure t
        :demand t
        :init
        (setq no-littering-etc-directory meta-config
              no-littering-var-directory meta-data))
    #+END_SRC

*** System and user specific configuration

    I run the same configuration on several machines. Different machines
    have different capabilities as well as different file system
    layouts. To handle this situation, I load system specific files based
    on the name of the machine. I also load in a file based on user name,
    to handle additional environments.

    My previous implementation for handling this had become too complicated
    and had some trouble with ordering. So, I have simplified things by
    having several functions.

**** Custom Settings

     Keep emacs Custom-settings in separate file. I previously converted
     most of my variable assignmets to setting custom variables during
     init. Therefore, the contents of the =custom.el= file is mostly
     populated from configuration.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(custom-file (expand-file-name "custom.el" user-emacs-directory)))
     #+END_SRC

**** Basic loading function

     #+BEGIN_SRC emacs-lisp
       (defun jme:load (directory base)
         "Look for files located in DIRECTORY whose base name is BASE.

       Check the base name against several extensions.  If a file with
       that name exists, then load it."
         (let ((literate      (expand-file-name (concat base ".org") directory))
               (encrypted-org (expand-file-name (concat base ".org.gpg") directory))
               (plain         (expand-file-name (concat base ".el") directory))
               (encrypted-el  (expand-file-name (concat base ".el.gpg") directory)))
          (cond
           ((file-exists-p encrypted-org) (org-babel-load-file encrypted-org))
           ((file-exists-p encrypted-el)  (load encrypted-el))
           ((file-exists-p literate)      (org-babel-load-file literate))
           ((file-exists-p plain)         (load plain)))))
     #+END_SRC

**** Private settings

     Personal information that should not be shared is kept in a private
     file.

     #+BEGIN_SRC emacs-lisp
       (jme:load user-emacs-directory ".private")
     #+END_SRC

**** OS-specific settings

     Settings specific to machine type are kept in their own settings file.

     #+BEGIN_SRC emacs-lisp
       (let* ((system-type-name (symbol-name system-type))
              (base-name (replace-regexp-in-string "/" "-" system-type-name)))
         (jme:load user-emacs-directory base-name))
     #+END_SRC

**** Hostname-specific settings

     Settings specific to a particular machine, identified by host name,
     are stored in their own settings file.

     #+BEGIN_SRC emacs-lisp
       (let ((host-name-base (car (split-string (system-name) "\\."))))
         (jme:load user-emacs-directory host-name-base))
     #+END_SRC

**** User-specific settings

     #+BEGIN_SRC emacs-lisp
       (jme:load user-emacs-directory user-login-name)
     #+END_SRC

**** Custom configuration

     Finally, we load any settings set by ~customize~.

     #+BEGIN_SRC emacs-lisp
       (load custom-file)
     #+END_SRC

** General Emacs Settings

   There are a number of configuration items I tend to look at as basic
   configuration. There is a fine line between what is a /package/ and what
   is just part of Emacs, especially at the rate things are being included
   in the /official/ distribution.

*** Window sizing

    When using a =window-system=, which I most often do, I like to start
    Emacs with a specific window size and position. This code accomplishes
    that.

    First, we need to set up the window sizing.

    #+BEGIN_SRC emacs-lisp
      (eval-when-compile
        (defvar emacs-min-top)
        (defvar emacs-min-left)
        (defvar emacs-min-height)
        (defvar emacs-min-width))

      (if window-system
          (unless noninteractive
            (defvar emacs-min-top 22)
            (defvar emacs-min-left 5)
            (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
            (defvar emacs-min-width 100)))
    #+END_SRC

    This function resets the window to its minimal position.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-min ()
      "Reset frame size to minumum."
        (interactive)
        (set-frame-parameter (selected-frame) 'fullscreen nil)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'top emacs-min-top)
        (set-frame-parameter (selected-frame) 'left emacs-min-left)
        (set-frame-parameter (selected-frame) 'height emacs-min-height)
        (set-frame-parameter (selected-frame) 'width emacs-min-width))
    #+END_SRC

    This function does the opposite of the above. It sets the window to
    maximum position.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-max ()
      "Reset frame size to maximum."
        (interactive)
        (if t
            (progn
              (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
              (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
              (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
          (set-frame-parameter (selected-frame) 'top 26)
          (set-frame-parameter (selected-frame) 'left 2)
          (set-frame-parameter (selected-frame) 'width
                               (floor (/ (float (x-display-pixel-width)) 9.15)))
          (if (= 1050 (x-display-pixel-height))
              (set-frame-parameter (selected-frame) 'height
                                   (if (>= emacs-major-version 24)
                                       66
                                     55))
            (set-frame-parameter (selected-frame) 'height
                                 (if (>= emacs-major-version 24)
                                     75
                                   64)))))
    #+END_SRC

    One last function to give me the ability to toggle between the two.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-toggle-size ()
      "Toggle between minimum and maximum size of frame."
        (interactive)
        (if (> (cdr (assq 'width (frame-parameters))) 100)
            (jme:emacs-min)
          (jme:emacs-max)))
    #+END_SRC

    I start off with Emacs in its minimal state when starting up. Since
    moving to the =mac= Emacs port on my Apple machines, as opposed to the
    =ns= version, I don't really use the toggle much anymore. Instead I use
    the mac fullscreen mode.

    #+BEGIN_SRC emacs-lisp
      (if window-system
          (add-hook 'after-init-hook 'jme:emacs-min))
    #+END_SRC

*** Coding system

    I am a fan of UTF-8. Make sure everything is set up to handle it.

    | Variable                     | Value   | Description          |
    |------------------------------+---------+----------------------|
    | =set-terminal-coding-system= | =utf-8= | terminal output      |
    | =set-terminal-coding-system= | =utf-8= | terminal input       |
    | =perfer-coding-system=       | =utf-8= | set preferred coding |

    #+BEGIN_SRC emacs-lisp
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
      (when (display-graphic-p)
        (custom-set-variables '(x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))))
    #+END_SRC

*** Interface settings

    I most often have the audio on my machines muted, so use the visible bell
    instead of beeps. Who likes beeps anyway?

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(visible-bell t))
    #+END_SRC

    Make sure I can see what it is that I am typing. This setting is the
    number of seconds to pause before unfinished commands are echoed. I
    find the default of 1 second a bit slow.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(echo-keystrokes 0.1))
    #+END_SRC

    I am not a big fan of overloading the arrow keys. Plus they are just too
    far away from my fingers to be useful. Don't use the shift+arrows for mark.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(shift-select-mode nil))
    #+END_SRC

    Use point instead of click with mouse yank.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(mouse-yank-at-point t))
    #+END_SRC

    While I no longer have a machine with a mouse connected (only trackpads
    now), I still use swipe-type scrolling which I would like to be smooth.

    These settings handle one line at a time, disable scrolling
    acceleration and scroll the window under the mouse.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(scroll-step 1)
                            '(mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
                            '(mouse-wheel-progressive-speed nil)            ; don't accelerate scrolling
                            '(mouse-wheel-follow-mouse 't))                 ; scroll window under mouse
    #+END_SRC

    Truncate lines in windows narrower than the frame. Providing an integer
    here specifies to truncate lines in each window narrower thant the full
    frame width, provided the total window width in column units is less
    than that integer; otherwise respect the value of =truncate-lines=.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(truncate-partial-width-windows 50))
    #+END_SRC

    Set the default tab stop.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(tab-width 4))
    #+END_SRC

    Never put tabs in files, use spaces instead. If, for some reason, a real
    tab is needed, use =C-q C-i= to insert one.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(indent-tabs-mode nil))
    #+END_SRC

    I want to always go to the next indent level when hitting return.

    #+BEGIN_SRC emacs-lisp
      (bind-key "RET" 'newline-and-indent)
    #+END_SRC

    Add newlines to the end of the file if I naviagate past it.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(next-line-add-newlines t))
    #+END_SRC

    Set the column that triggers fill

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(fill-column 75))
    #+END_SRC

    Turn on auto fill for text files.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
    #+END_SRC

    Allow narrowing.

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-defun 'disabled nil)
      (put 'narrow-to-page 'disabled nil)
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

*** Visual tweaks

    Unlike a number of people, I do not mind the menu bar if I am actually
    using a window system of some kind. It is not that I use it often, but
    it does not get in my way much either. So, I check to see if I am using
    a window system and disable it if not. Turns out that this is still
    annoying when the window system does not support global menus as is the
    case when I am running on my chromebook with i3wm. Still need a
    solution for that case.

    #+BEGIN_SRC emacs-lisp
      (if (eq window-system 'nil)
          (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode 1)))
    #+END_SRC

    The toolbar, however, is completely useless to me, so I always disable it.

    #+BEGIN_SRC emacs-lisp
      (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    #+END_SRC

    Likewise, scrollbars offer no value.

    #+BEGIN_SRC emacs-lisp
      (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    #+END_SRC

    Don't show the startup message.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(inhibit-startup-message t)
                            '(inhibit-startup-echo-area-message (user-login-name)))
    #+END_SRC

    Visually indicate empty lines after the buffer end. This is shown as a
    fringe bitmap in the left edge.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(indicate-empty-lines t))
    #+END_SRC

**** Icon support

     #+BEGIN_SRC emacs-lisp
       (use-package all-the-icons
        :ensure t)
     #+END_SRC

**** Modeline

     I refer to my modeline quite often. It is very easy for it to get too
     cluttered, it is expensive real estate.

     Show the line:column number.

     #+BEGIN_SRC emacs-lisp
       (line-number-mode 1)
       (column-number-mode 1)
     #+END_SRC

     Also, show the size of the file.

     #+BEGIN_SRC emacs-lisp
       (size-indication-mode 1)
     #+END_SRC

***** Battery information

      I have opted for a simpler and 'clearer' solution to displaying
      battery information utilizing the `fancy-battery` package.

      #+BEGIN_SRC emacs-lisp
        (use-package fancy-battery
          :ensure t
          :config
          (add-hook 'after-init-hook #'fancy-battery-mode))
      #+END_SRC

***** Time

      I often run emacs in a fullscreen fashion that does not display the
      system clock on my desktop. However, I often refer to the clock, thus
      I add it to the modeline. The =display-time= functionality in Emacs
      is quite robust and can potentially display much more information
      than just the time. I configure it here to my liking.

      #+BEGIN_SRC emacs-lisp
        (custom-set-variables '(display-time-default-load-average nil)  ; Don't display load
                              '(display-time-day-and-date nil)          ; Don't display date
                              '(display-time-format "%l:%M%p"))
        (add-hook 'after-init-hook #'display-time-mode)
      #+END_SRC

*** Miscellaneous

    Add newline to end of file on save.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(require-final-newline t))
    #+END_SRC

    Make Emacs use the clipboard

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(select-enable-clipboard t))
    #+END_SRC

    Prefix used for generating the auto save file names.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(auto-save-list-file-prefix meta-saves))
    #+END_SRC

    Use "y" in place of "yes", who wants to type all of those extra characters?

    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

**** Bookmarks

     Save bookmarks into their own file in the meta information directory.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(bookmark-default-file meta-bookmarks))
     #+END_SRC

**** Backup

     I like all of my backup copies of files to be in a common location.

     Configure where the backups should go.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(backup-directory-alist (quote ((".*" . "~/.emacs-meta/backups/")))))
     #+END_SRC

     I like to use version numbers for the backup files. Set the number of
     newest versions and oldest versions to keep when a new numbered backup
     is made. I also don't care about the deletion of excess backup
     versions, so do that silently. Also, I like to use copying to create
     backups for files that are linked, instead of renaming.

     | Variable                        | Value | Description                                                          |
     |---------------------------------+-------+----------------------------------------------------------------------|
     | =version-control=               | =t=   | Control use of version numbers for backup files                      |
     | =kept-new-versions=             | =2=   | Number of newest versions to keep when a new numbered backup is made |
     | =kept-old-versions=             | =2=   | Number of oldest versions to keep when a new numbered backup is made |
     | =delete-old-versions=           | =t=   | When set to =t=, delete excess backup versions silently              |
     | =backup-by-copying-when-linked= | =t=   | Use copying to create backups for files with multiple names          |

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables
         '(version-control t)
         '(kept-new-versions 2)
         '(kept-old-versions 2)
         '(delete-old-versions t)
         '(backup-by-copying-when-linked t))
     #+END_SRC

**** URL Related

     Make sure to store URL related stuff in the right place.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(url-cookie-file (concat meta-url "/cookies"))
                             '(url-cache-directory (concat temporary-file-directory "url/cache")))
     #+END_SRC

*** Global mode settings

**** Auto-revert

     Revert buffers when they change on disk.

     #+BEGIN_SRC emacs-lisp
       (global-auto-revert-mode 1)
     #+END_SRC

     Auto-refresh dired buffers.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(global-auto-revert-non-file-buffers t))
     #+END_SRC

     But.. don't announce reversion of buffer

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(auto-revert-verbose nil))
     #+END_SRC

**** Git gutter

     Git gutter is a nice little utility that adds markers in the fringe to
     denote changes in a file. I like this everywhere, so I turn it on
     globally.

     #+BEGIN_SRC emacs-lisp
       (use-package git-gutter-fringe
         :ensure t
         :diminish git-gutter-mode
         :config
         (progn
           (custom-set-variables '(git-gutter:lighter " GG"))
           (global-git-gutter-mode)))
     #+END_SRC

**** Git messenger

     #+BEGIN_SRC emacs-lisp
       (use-package git-messenger
         :ensure t
         :commands git-messenger:popup-message
         :bind ("C-x v p" . git-messenger:popup-message))
     #+END_SRC

**** Recentf

     Save recently used files. This turns on the "Open Recent" submenu
     which is displayed in the "File" menu, containing a list of files that
     were operated on recently.

     I use the following settings for this mode:

     | variable                 |         value | description                       |
     |--------------------------+---------------+-----------------------------------|
     | =recentf-save-file=      | =meta-recent= | File to save the recent list into |
     | =recent-max-saved-items= |           100 | Max number of items saved         |
     | =recent-max-menu-items=  |            15 | Max number of items in menu       |

     Since the loading of the recent file and cleanup can take some time, I
     turn it on once things are idle.

     #+BEGIN_SRC emacs-lisp
       (use-package recentf
         :config
         (progn
           (custom-set-variables
             '(recentf-save-file meta-recent)
             '(recentf-max-saved-items 100)
             '(recentf-max-menu-items 15))
           (recentf-mode t)))
     #+END_SRC

**** Savehist

     Save minibuffer history. The minibuffer history is saved periodically
     (every 300 seconds, in this case) and when exiting Emacs. I use
     =savehist-file= to specify the filename (in the meta information
     directory) where the history should be stored. Additionally, I have it
     set to save:

     | History type         | Description                                        |
     |----------------------+----------------------------------------------------|
     | =search-ring=        | List of search string sequences                    |
     | =regexp-search-ring= | List of regular expression search string sequences |

     #+BEGIN_SRC emacs-lisp
       (use-package savehist
         :config
         (progn
           (custom-set-variables '(savehist-additional-variables
                                   '(kill-ring search-ring regexp-search-ring))
                                 '(savehist-autosave-interval 300)
                                 '(savehist-file meta-savehist)
                                 '(history-delete-duplicates t))
           (savehist-mode t)))
     #+END_SRC

**** Saveplace

     Preserve the location of point in file when saving files.

     I specify the name of the file that records saveplace information, so
     the contents go into the =meta= area and activate it for all buffers.

     #+BEGIN_SRC emacs-lisp
       (use-package saveplace
         :init
         (progn
           (custom-set-variables '(save-place-file meta-saveplace))
           (save-place-mode t)))
     #+END_SRC

**** Smartparens

     I like to visually see the matching parens. =smartparens-mode= is a
     global minor mode that highlights matching parens.

     If there are specific modes in which =smartparens-mode= should not be
     enabled, they can be added to the =sp-ignore-modes-list=.

     #+BEGIN_SRC emacs-lisp
       (use-package smartparens
         :ensure t
         :commands (smartparens-mode
                    show-smartparens-mode
                    show-smartparens-global-mode)
         :demand t
         :diminish smartparens-mode
         :config
         (progn
           (require 'smartparens-config)
           (smartparens-global-mode)))
     #+END_SRC

**** Undo-tree-mode

     =undo-tree-mode= replaces Emacs' standard undo feature with a more
     powerful, yet easier to user version, that treats the undo history as
     what it is: a tree.

     If a specific mode is not compatible with =undo-tree-mode=, it can be
     added to the list =undo-tree-incompatible-major-modes=.

     Enable =undo-tree-mode= globally.

     #+BEGIN_SRC emacs-lisp
       (use-package undo-tree
         :ensure t
         :diminish undo-tree-mode
         :config
         (progn
           (custom-set-variables '(undo-tree-visualizer-timestamps t)
                                 '(undo-tree-visualizer-diff t))
           (global-undo-tree-mode)))
     #+END_SRC

**** Whitespace

     I like to see whitespace in files. I find this helps with both
     organization and formatting. I use the following style for whitespace
     visualization:

     | Style            | Description                           |
     |------------------+---------------------------------------|
     | face             | enable all visualization via faces    |
     | trailing         | trailing blanks                       |
     | space-before-tab | SPACEs before TAB                     |
     | space-after-tab  | 8 or more SPACEs after a TAB          |
     | indentation      | 8 or more SPACEs at beginning of line |

     I also specify the column beyond which the line is highlighted.

     #+BEGIN_SRC emacs-lisp
       (use-package whitespace
         :diminish global-whitespace-mode
         :config
         (progn
           (custom-set-variables '(whitespace-style '(face trailing space-before-tab
                                                      indentation space-after-tab))
                                 '(whitespace-line-column 80))
           (global-whitespace-mode 1)))
     #+END_SRC

**** Winner

     Winner mode is a minor mode which keeps a history of changes to window
     configurations. This allows you to easily undo (=winner-undo=) and
     redo (=winner-redo=) window configurations.

     #+BEGIN_SRC emacs-lisp
       (use-package winner
         :ensure t
         :if (not noninteractive)
         :demand t
         :config (winner-mode 1))
     #+END_SRC

* Utility functions

  There are a number of /utility/ functions that I keep around for handling
  different things. Some of them are experimental, but they /do/ work.

** Hide or Expand

   I have kept this around for a long time and go through different phases
   of using it. I have recently gone back to using it quite a bit now that
   I have been using =winner= mode.

   #+BEGIN_SRC emacs-lisp
     (defun hide-or-expand ()
       "Hide or expand a window."
       (interactive)
       (if (> (length (window-list)) 1)
           (delete-other-windows)
         (bury-buffer)))
   #+END_SRC

* Package Specific Settings
** Avy

   Replacement for ace-jump-mode and other things.

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1
       :bind ("C-. C-s" . avy-goto-word-1))
   #+END_SRC

** Aggressive Indent

   Avoid manual indentation with 'aggressive indent'. I am not sure I am
   comfortable with this mode anywhere but in lisp code just yet.

   It can be turned on globally with =(global-aggressive-indent-mode 1)=.

   If used globally, specific modes can be excluded with the list
   =aggressive-indent-excluded-modes=.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
        :ensure t
        :diminish (aggressive-indent-mode . "➠")
        :config
          (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
   #+END_SRC

** Auto complete (Company)

   I have fiddled around with different auto-completion packages and
   extensions over time. This one works.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :diminish company-mode
       :config
       (global-company-mode)
       :init
       (progn
         (custom-set-variables '(company-tooltip-limit 20)
                               '(company-idle-delay .3))))
   #+END_SRC

   Also enable fuzzy matching.

   #+BEGIN_SRC emacs-lisp
     (use-package company-flx
       :ensure t
       :after company
       :config
       (company-flx-mode +1))
   #+END_SRC

** YASnippet

   YASnippet is an excellent template system for Emacs and it works very
   well with Auto Complete. I use it everywhere I can.

   YASnippet does not provide a way to expand a snippet programmatically,
   so we create one. (Based on code from [[http://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][this]] Stack Overflow question.)

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :diminish yas-minor-mode
       :config (yas-global-mode 1))

     (defun jme:insert-yas-by-name (name)
       "Insert YASnippet by NAME."
       (cl-flet ((dummy-prompt
                  (prompt choices &optional display-fn)
                  (declare (ignore prompt))
                  (or (find name choices :key display-fn :test #'string=)
                      (throw 'notfound nil))))
         (let ((yas-prompt-functions '(dummy-prompt)))
           (catch 'notfound
             (yas-insert-snippet t)))))
   #+END_SRC

   Add =helm= support for yas.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-c-yasnippet
       :ensure t
       :after helm
       :bind ("C-c y" . helm-yas-complete)
       :config (custom-set-variables '(helm-yas-space-match-any-greedy t)))
   #+END_SRC

   Here we provide an indication that there is a yasnippet available to be
   used. (From [[https://github.com/pcmantz/elisp/blob/master/my-bindings.el][here]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-132][here]]).

   #+BEGIN_SRC emacs-lisp
     (defvar default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))
       "Capture the default cursor color so we can switch back to it if needed.")
     (defvar yasnippet-can-fire-cursor-color "purple"
       "Color to change cursor when yasnippet is available.")

     (defun jme:yasnippet-can-fire-p (&optional field)
       "Test if yasnippet can expand based on FIELD."
       (interactive)
       (setq yas--condition-cache-timestamp (current-time))
       (let (templates-and-pos)
         (unless (and yas-expand-only-for-last-commands
                      (not (member last-command yas-expand-only-for-last-commands)))
           (setq templates-and-pos (if field
                                       (save-restriction
                                         (narrow-to-region (yas--field-start field)
                                                           (yas--field-end field))
                                         (yas--templates-for-key-at-point))
                                     (yas--templates-for-key-at-point))))
         (and templates-and-pos (first templates-and-pos))))

     (defun jme:change-cursor-color-when-can-expand (&optional field)
       "Update the cursor color if a snippet is available, based on FIELD."
       (interactive)
       (when (eq last-command 'self-insert-command)
         (set-cursor-color (if (jme:can-expand)
                               yasnippet-can-fire-cursor-color
                             default-cursor-color))))

     (defun jme:can-expand ()
       "Return true if right after an expandable thing."
       (or (abbrev--before-point) (jme:yasnippet-can-fire-p)))

     (add-hook 'post-command-hook 'jme:change-cursor-color-when-can-expand)
   #+END_SRC

** Clojure

   Support for Clojure.

*** Clojure Mode

    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :init
        (progn
          (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
          (add-hook 'clojure-mode-hook #'smartparens-strict-mode)))
    #+END_SRC

*** Cider

    #+BEGIN_SRC emacs-lisp
      (use-package cider
        :ensure t
        :init
        (progn
          (add-hook 'cider-mode-hook #'eldoc-mode)
          (add-hook 'cider-mode-hook #'rainbow-delimiters-mode)
          (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
          (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)))
    #+END_SRC

*** Clojure Cheatsheet
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-cheatsheet
        :ensure t)
    #+END_SRC

*** Clojure mode extra font locking
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode-extra-font-locking
        :ensure t)
    #+END_SRC

*** Clojure snippets for Yasnippets
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-snippets
        :ensure t)
    #+END_SRC

*** Flycheck for Clojure
    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-clojure
        :ensure t)
    #+END_SRC

*** Slamhound
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package slamhound
        :disabled t)
    #+END_SRC

** CSS

   Mode for handling CSS.

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode)
   #+END_SRC

** Dired

   I have been trying to train myself to use =dired= as much as
   possible. My go-to alternative is the command line, which often
   interrupts whatever I was doing in the particular shell I choose. My
   settings here are still very much experimental.

   I moved to using =dired+= to pick up some extra features.

   Make sure =image-dired= keeps its files in the meta directory.

   #+BEGIN_SRC emacs-lisp
     (use-package dired+
       :ensure t
       :config
       (progn
         (custom-set-variables '(image-dired-dir (concat metafiles-dir "/image-dired")))
         (put 'dired-find-alternate-file 'disabled nil)  ;enable `a' command
         (diredp-toggle-find-file-reuse-dir 1)))
   #+END_SRC

   All-the-icons support in dired buffers. Becasue, who doesn't like icons?

   #+BEGIN_SRC emacs-lisp
   (use-package all-the-icons-dired
    :ensure t
    :after all-the-icons
    :commands all-the-icons-dired-mode
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
   #+END_SRC

   Subtree support.

   #+BEGIN_SRC emacs-lisp
     (use-package dired-subtree
       :ensure t
       :commands (dired-subtree-insert dired-subtree remove)
       :after dired
       :bind (:map dired-mode-map
                   ("i" . dired-subtree-insert)
                   (";" . dired-subtree-remove)))
   #+END_SRC

   Filter support.

   #+BEGIN_SRC emacs-lisp
     (use-package dired-filter
       :ensure t
       :after dired
       :config
       (custom-set-variables '(dired-filter-group-saved-groups '(("default"
                                                                  ("Archives"
                                                                   (extension "zip" "rar" "gz" "bz2" "tar"))
                                                                  ("Data"
                                                                   (extension "json" "xml" "dat" "csv"))
                                                                  ("Documents"
                                                                   (extension "org" "markdown" "md" "adoc" "txt"))
                                                                  ("Binary"
                                                                   (extension "elc" "pyc"))
                                                                  ("Backup"
                                                                   (extension "el~" "backup"))
                                                                  ("Language"
                                                                   (extension "el" "py" "java" "sh" "awk" "rb"))
                                                                  ("LaTeX"
                                                                   (extension "tex" "bib"))
                                                                  ("Mac"
                                                                   (extension . "DS_Store"))
                                                                  ("PDF"
                                                                   (extension . "pdf"))
                                                                  ("Version Control"
                                                                   (extension "git" "gitignore" "gitconfig" "gitmodules"))
                                                                  )))))
   #+END_SRC

** Elfeed

   A utility mode for reading RSS.

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed-org
       :ensure t
       :after elfeed
       :config
       (progn
         (custom-set-variables '(rmh-elfeed-org-files (list "~/.elfeed/elfeed.org")))
         (elfeed-org)))
   #+END_SRC

** Expand Region

   A fantastically useful package to gradually expand selected region.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :commands er/expand-region
       :bind ("C-=" . er/expand-region))
   #+END_SRC

** Flycheck

   Removed snippet:

   (custom-set-variables '(flycheck-disabled-checkers
                               (append flycheck-disabled-checkers
                                       '(javascript-jshint))))

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :diminish flycheck-mode
       :config
       (progn
         (custom-set-variables '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages))
         (flycheck-clojure-setup)
         (global-flycheck-mode)
         (flycheck-add-mode 'javascript-eslint 'web-mode)
         (flycheck-add-mode 'html-tidy 'web-mode)
         (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-pos-tip
       :ensure t)
   #+END_SRC

** Flyspell

   I often use =flyspell= mode when writing text documents. I typically
   turn this on a some point after I have already begun writing. This bit
   of advice ensures that the buffer is checked when I turn =flyspell= on.

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :config
       (defadvice flyspell-mode (after advice-flyspell-check-buffer-on-start activate)
         (flyspell-buffer)))
   #+END_SRC

** Guide Key

   Nice utility for providing a guide for key bindings.

   #+BEGIN_SRC emacs-lisp
     (use-package guide-key
       :diminish guide-key-mode
       :ensure t
       :config
       (progn
         (custom-set-variables
         '(guide-key/guide-key-sequence '("C-x" "C-c"))
         '(guide-key/recursive-key-sequence-flag t)
         '(guide-key/popup-window-position 'bottom))
         (guide-key-mode 1)))
   #+END_SRC

** Helm

   Helm helps with completion of many things. I am finding it easier to
   work with than other modules.

   #+BEGIN_SRC emacs-lisp
     (defvar jme:helm-sources '(helm-source-buffers-list
                                helm-source-recentf
                                helm-source-bookmarks
                                helm-source-file-cache
                                helm-source-files-in-current-dir))
     (use-package helm
       :ensure t
       :diminish helm-mode
       :config
       (progn
         (require 'helm-config)
         (custom-set-variables '(helm-for-files-preferred-list jme:helm-sources)
                               '(helm-split-window-in-side-p t)
                               '(helm-scoll-amount 8))
         (helm-mode 1)
         (helm-autoresize-mode 1))
       :bind (("C-x b" . helm-mini)
              ("C-x C-b" . helm-buffers-list)
              ("C-x C-f" . helm-find-files)
              ("M-x" . helm-M-x)
              ("M-y" . helm-show-kill-ring)
              ("C-c h g" . helm-google-suggest)
              ("C-c h o" . helm-occur)
              ("C-c h x" . helm-register)
              ("C-c h SPC" . helm-all-mark-rings)
              ("C-h a" . helm-apropos)
              ("M-s a" . helm-do-grep)
              ("M-s f" . helm-for-files)))
   #+END_SRC

   Helm can do a great job of describing bindings.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-descbinds
       :ensure t
       :commands (helm-descbinds)
       :bind ("C-h b" . helm-descbinds))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package helm-swoop
       :commands (helm-swoop helm-swoop-back-to-last-point)
       :ensure t
       :bind (("C-c h s" . helm-swoop)
              ("M-i" . helm-swoop)
              ("M-I" . helm-swoop-back-to-last-point)
              :map isearch-mode-map
              ("M-i" . helm-swoop-from-isearch)
              :map helm-swoop-map
              ("M-i" . helm-multi-swoop-all-from-helm-swoop)
              ("C-s" . helm-next-line)
              ("C-r" . helm-previous-line)))
   #+END_SRC

*** Flycheck

    Add helm support for flycheck.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-flycheck
        :ensure t)
    #+END_SRC

** Javascript

   Make sure to handle json files appropriately.

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :ensure t
       :commands json-mode
       :mode ("\\.json$" . json-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :ensure t
       :commands js2-mode
       :mode ("\\.js$" . js2-mode)
       :bind (:map js2-mode-map
                   ("C-x C-e" . js-send-last-sexp)
                   ("C-M-x" . js-send-last-sexp-and-go)
                   ("C-c b" . js-send-buffer)
                   ("C-c l" . js-load-file-and-go))
       :init
       (progn
         (add-to-list 'interpreter-mode-alist (cons "node" 'js2-mode))))
   #+END_SRC

   If we have the ability to use javascript in an inferior process, use
   Node for that.

   #+BEGIN_SRC emacs-lisp
     (use-package js-comint
       :disabled t
       :init
       (custom-set-variables '(inferior-js-program-command "node")))
   #+END_SRC

** Lisp

   Eldoc provides minibuffer hints when working with Emacs lisp.

   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :diminish eldoc-mode
       :commands eldoc-mode
       :bind (:map emacs-lisp-mode-map
              ("C-c ." . find-function-at-point)
              ("C-c f" . find-function)
              ("M-:" . pp-eval-expression))
       :init
       (progn
         (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
         (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)))

     (add-hook 'lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
     (add-hook 'emacs-lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
   #+END_SRC

** Magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands magit-status
       :ensure t
       :bind ("C-x d" . magit-status))
   #+END_SRC

** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :commands markdown-mode
       :mode
       (("\\.markdown$" . markdown-mode)
        ("\\.md$" . markdown-mode)))
   #+END_SRC

** Org

   My =org= mode settings are contained in their own file. This function
   loads the configuration based on my login name.

   #+BEGIN_SRC emacs-lisp
     (jme:load user-emacs-directory (concat user-login-name "-org"))
   #+END_SRC

** Paradox

   Better package management.

   #+BEGIN_SRC emacs-lisp
     (use-package paradox
       :ensure t
       :commands paradox-list-packages)
   #+END_SRC

** PDF-tools

   Package has been pinned to =manual=, since it requires an extra install
   step.

   After updating, the package needs to be activated with =(pdf-tools-install)=.

   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :pin manual
       :bind (:map pdf-view-mode-map
              ("h" . pdf-annot-add-highlight-markup-annotation)
              ("t" . pdf-annot-add-text-annotation)
              ("D" . pdf-annot-delete))
       :config
       (progn
         (setq-default pdf-view-display-size 'fit-page)
         (setq pdf-annot-activate-created-annotations t)))
   #+END_SRC

** Projectile

   Projectile works as a nice, light-weight, project management tool.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :diminish projectile-mode
       :config
       (progn
         (custom-set-variables '(projectile-cache-file (concat metafiles-dir "/projectile.cache"))
                               '(projectile-known-projects-file (concat metafiles-dir "/projectile-bookmarks.eld"))
                               '(projectile-keymap-prefix (kbd "C-c p"))
                               '(projectile-enable-caching t))
         (projectile-mode)))
   #+END_SRC

   Support for org tasks associated with projectile projects.

   #+BEGIN_SRC emacs-lisp
;     (use-package org-projectile
;       :ensure t
;       :bind (("C-c n p" . org-projectile-project-todo-completing-read)
;              ("C-c c" . org-capture))
;       :config
;       (progn
;         (setq org-projectile-projects-file
;               (concat metafiles-dir "projects.org"))
;         (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
;         (push (org-projectile-project-todo-entry) org-capture-templates)))
   #+END_SRC

   Projectile Helm support.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t
       :after projectile
       :config
       (progn
         (custom-set-variables '(projectile-completion-system 'helm)
                               '(projectile-switch-project-action 'helm-projectile))
         (helm-projectile-on)))

;     (use-package org-projectile-helm
;       :after org-projectile
;       :bind (("C-c n p" . org-projectile-helm-template-or-project)))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     ; Bring back indent after newline
     (add-hook 'python-mode-hook '(lambda ()
                  (define-key python-mode-map "\C-m" 'newline-and-indent)))

   #+END_SRC

   Use python3

   #+BEGIN_SRC emacs-lisp
     (setq python-shell-interpreter "python3"
           python-shell-interpreter-args "-i")
   #+END_SRC

   use ipython (no more)

   #+BEGIN_SRC emacs-lisp :tangle no
     (setq python-shell-interpreter "ipython"
            python-shell-interpreter-args "-i -v")
   #+END_SRC

   Jedi for Python. To use auto-complete with Jedi, we require only
   company-jedi and not make reference to jedi-core package.

   #+BEGIN_SRC emacs-lisp
     (use-package company-jedi
       :ensure t
       :commands (jedi:goto-definition jedi-mode company-jedi)
       :bind (:map python-mode-map
                   ("M-." . jedi:goto-definition)
                   ("M-," . jedi:goto-definition-pop-marker))
       :config
       (setq jedi:complete-on-dot t))
   #+END_SRC

   Highlight indentation

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-indent-guides
      :ensure t
      :commands highlight-indent-guides-mode
      :init
      (progn
       (custom-set-variables '(highlight-indent-guides-method 'character))
       (add-hook 'python-mode-hook 'highlight-indent-guides-mode)))
   #+END_SRC

*** Anaconda

    #+BEGIN_SRC emacs-lisp
      (use-package anaconda-mode
        :ensure t
        :commands anaconda-mode
        :init (add-hook 'python-mode-hook 'anaconda-mode))
    #+END_SRC

*** Company Anaconda

    #+BEGIN_SRC emacs-lisp
      (use-package company-anaconda
        :ensure t
        :after company
        :config
        (add-to-list 'company-backends '(company-anaconda :with company-capf)))
    #+END_SRC

*** Helm Pydoc

    #+BEGIN_SRC emacs-lisp
      (use-package helm-pydoc
        :ensure t
        :after helm
        :commands helm-pydoc
        :bind (:map python-mode-map ("C-c C-d" . helm-pydoc)))
    #+END_SRC

*** Nose

    #+BEGIN_SRC emacs-lisp
      (use-package nose
        :ensure t
        :after python
        :commands (nosetests-one
                   nosetests-pdb-one
                   nosetests-all
                   nosetests-pdb-all
                   nosetests-module
                   nosetests-pdb-module
                   nosetests-suite
                   nosetests-pdb-suite)
        :config
        (add-hook 'python-mode-hook (lambda () (nose-mode t))))
    #+END_SRC

*** Pythonic

    #+BEGIN_SRC emacs-lisp
    (use-package pythonic
      :ensure t
      :commands pythonic-activate)
    #+END_SRC


** Java

*** Eclim

    Eclipse front-end for Java development.

    #+BEGIN_SRC emacs-lisp
      (use-package eclim
        :commands eclim-mode
        :config
        (progn
          (use-package company-emacs-eclim
            :after company
            :config
            (company-emacs-eclim-setup))
          (setq eclimd-autostart t)
          (add-hook 'java-mode-hook (lambda () (eclim-mode 1)))))
    #+END_SRC

*** Java utilities

    Auto byte-code disassembly.

    #+BEGIN_SRC emacs-lisp
      (use-package autodisass-java-bytecode
        :ensure t
        :defer t)
    #+END_SRC

** Rainbow mode

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :commands rainbow-mode
       :ensure t
       :after css-mode
       :init
       (add-hook 'css-mode-hook 'rainbow-mode))
   #+END_SRC

** Shell

   I try to use my shell within Emacs as much as possible. I will admit
   that I have not yet been able to do this completely, though the desire
   is there.

*** eshell

    Additional references:

    - [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][Mikey Petersen's Mastering Eshell]]
    - [[http://www.modernemacs.com/post/custom-eshell/][Modern Emacs: Making eshell your own]]
    - [[https://www.emacswiki.org/emacs/EshellPrompt][EmacsWiki: EshellPrompt]]
    - [[http://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/][Liang Zan: Customozing Your Emacs Eshell Propmpt]]

    Packages:

    - [[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]]
    - [[https://github.com/kaihaosw/eshell-prompt-extras][eshell-prompt-extras]]

**** Prompt

     #+BEGIN_SRC emacs-lisp
       (use-package eshell-git-prompt
         :ensure t
         :config
         (eshell-git-prompt-use-theme 'powerline))
     #+END_SRC


**** Configuration

***** Control files

      #+BEGIN_SRC emacs-lisp
        (custom-set-variables '(eshell-directory-name (concat metafiles-dir "/eshell/")))
      #+END_SRC

***** Visual Commands

      Eshell has support for special handling of commands which present their
      output in a visual fashion (see help for =eshell-visual-commands=).

      Typically, these are commands which require a proper terminal
      environment to run in. =eshell= will run them in a term buffer when
      they are invoked.

      The emacs defaults are:

      - vi
      - screen
      - top
      - less
      - more
      - lynx
      - ncftp
      - pine
      - tin
      - trn
      - elm

      I don't use a lot of these commands and there are others I do use.

     #+BEGIN_SRC emacs-lisp
       (setq eshell-visual-commands
             '("less" "tmux" "top" "bash" "zsh"))
     #+END_SRC

      The =eshell-visual-subcommands= specifies an alist of subcommands which
      present their output visually, in much the same way as specified
      above. In this case, however, you can specify specific arguments which
      trigger the behavior.

      I find this to be especially useful for =git= commands which display
      tree information (like log). I have a number of aliases set up with git
      which I want to ensure are covered.

     #+BEGIN_SRC emacs-lisp
       (setq eshell-visual-subcommands
             '(("git"
                "diff" "df" "dc"
                "show"
                "log" "lg" "tree" "lol" "lola" "lala" "ltla" "ldla")))
     #+END_SRC

*** comint

    #+BEGIN_SRC emacs-lisp
      (use-package comint
        :bind (:map comint-mode-map
                    ("M-p" . comint-previous-matching-input-from-input)
                    ("M-n" . comint-next-matching-input-from-input)
                    ("C-M-n" . comint-next-input)
                    ("C-M-p" . comint-previous-input))
        :init
        (progn
          (custom-set-variables '(comint-prompt-read-only t))
          (add-hook 'term-exec-hook
                    (function
                     (lambda ()
                       (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))))
    #+END_SRC

*** Tramp

    Tramp is a fantastic package that allows for remote file editing. Make
    sure tramp uses ssh by default. Also make sure that files are stored in
    the meta information directory.

    #+BEGIN_SRC emacs-lisp
      (use-package tramp
        :init
        (custom-set-variables
          '(tramp-default-method "ssh")
          '(tramp-persistency-file-name meta-tramp)))
    #+END_SRC

** Uniquify

   By default, Emacs makes buffer names unique by adding =<2>=, =<3>=,
   etc. to the end of the buffer name. I don't find this particularly
   useful. Using the =Uniquify= package, I can easily change this behavior.

   Use the =post-forward= type of naming for buffers. This names the buffer
   with the file name followed by a shortened form of the path.

   For example:

   =/foo/bar/mumble/name= becomes =name|bar/mumble=

   I change the string used as a separator for the buffer name components
   to be ":".

   Also, make sure to rerationalize buffer names after a buffer has been
   killed.

   Some buffers should not be uniquified. I also provide a regular
   expression here for these exceptions.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :init
       (custom-set-variables
         '(uniquify-buffer-name-style 'post-forward)
         '(uniquify-separator ":")
         '(uniquify-after-kill-buffer-p t)
         '(uniquify-ignore-buffers-re "^\\*")))
   #+END_SRC

** Web mode

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :mode
       (("\\.jsx$" . web-mode)
        ("\\.html?\\'" . web-mode))
       :config
       (progn
         (custom-set-variables '(web-mode-markup-indent-offset 2)
                               '(web-mode-css-indent-offset 2)
                               '(web-mode-code-indent-offset 2)
                               '(web-mode-enable-current-column-highlight t))
         (defadvice web-mode-highlight-part (around tweak-jsx activate)
           (if (equal web-mode-content-type "jsx")
               (let ((web-mode-enable-part-face nil))
                 ad-do-it)
             ad-do-it))
         (add-hook 'web-mode-hook
                   (lambda ()
                     (when (equal web-mode-content-type "jsx")
                       (flycheck-select-checker 'javascript-eslint)
                       (flycheck-select-checker 'flycheck-tidyrc))))))
   #+END_SRC

** Diminish

   I use diminish to hide most of minor modes from the modeline. Most of
   the diminish functionality has been updated into the =use-package=
   calls.

   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :ensure t
       :config
       (progn
         (eval-after-load "highlight-indentation" '(diminish 'highlight-indentation-mode))
         (diminish 'auto-revert-mode)
         (diminish 'auto-fill-function)
         (diminish 'overwrite-mode "💀")))
   #+END_SRC

* Custom Configuration

** Window handling

*** Rotating Windows

    I often have my frame split into multiple windows. I find it very handy
    to swap buffers between windows if I am working in multiple buffers at
    the same time. I came across this function to rotate buffers through
    windows (you can find it [[http://whattheemacsd.com/buffer-defuns.el-02.html][here]].)

    #+BEGIN_SRC emacs-lisp
      (defun jme:rotate-windows ()
        "Rotate your windows."
        (interactive)
        (cond ((not (> (count-windows)1))
               (message "You can't rotate a single window!"))
              (t
               (let ((i 1)
                     (numWindows (count-windows)))
               (while  (< i numWindows)
                 (let* (
                        (w1 (elt (window-list) i))
                        (w2 (elt (window-list) (+ (% i numWindows) 1)))
                        (b1 (window-buffer w1))
                        (b2 (window-buffer w2))
                        (s1 (window-start w1))
                        (s2 (window-start w2))
                        )
                   (set-window-buffer w1  b2)
                   (set-window-buffer w2 b1)
                   (set-window-start w1 s2)
                   (set-window-start w2 s1)
                   (setq i (1+ i))))))))
    #+END_SRC

*** Window Split

    This function toggles between horizontal and vertical layout of two
    windows. (Picked up from [[http://whattheemacsd.com/buffer-defuns.el-03.html][here]].)

    #+BEGIN_SRC emacs-lisp
      (defun jme:toggle-window-split ()
       "Toggle between horizontal and vertical layout of windows."
        (interactive)
        (if (= (count-windows) 2)
            (let* ((this-win-buffer (window-buffer))
                   (next-win-buffer (window-buffer (next-window)))
                   (this-win-edges (window-edges (selected-window)))
                   (next-win-edges (window-edges (next-window)))
                   (this-win-2nd (not (and (<= (car this-win-edges)
                                               (car next-win-edges))
                                           (<= (cadr this-win-edges)
                                               (cadr next-win-edges)))))
                   (splitter
                    (if (= (car this-win-edges)
                           (car (window-edges (next-window))))
                        'split-window-horizontally
                      'split-window-vertically)))
              (delete-other-windows)
              (let ((first-win (selected-window)))
                (funcall splitter)
                (if this-win-2nd (other-window 1))
                (set-window-buffer (selected-window) this-win-buffer)
                (set-window-buffer (next-window) next-win-buffer)
                (select-window first-win)
                (if this-win-2nd (other-window 1))))))
    #+END_SRC

*** More window splitting

    I really like the idea of the following functions (covered by Sacha
    [[https://www.youtube.com/watch?v%3DnKCKuRuvAOw&feature%3Dyoutu.be][here]], original source [[http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][here]]). I don't override the normal split
    keybindings since I very often want several windows with the same
    buffer.

    #+BEGIN_SRC emacs-lisp
      (defun jme:vsplit-last-buffer (prefix)
        "Split the window vertically and display the previous buffer."
        (interactive "p")
        (split-window-vertically)
        (other-window 1 nil)
        (if (= prefix 1)
          (switch-to-next-buffer)))
      (defun jme:hsplit-last-buffer (prefix)
        "Split the window horizontally and display the previous buffer."
        (interactive "p")
        (split-window-horizontally)
        (other-window 1 nil)
        (if (= prefix 1) (switch-to-next-buffer)))
    #+END_SRC

*** Window switching

    #+BEGIN_SRC emacs-lisp
      (use-package ace-window
        :ensure t
        :commands ace-window
        :bind ("C-x o" . ace-window)
        :config (custom-set-variables '(aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))))
    #+END_SRC

** Cleanup

   Whitespace cleanup can be dangerous if it changes the content of the
   file. Some changes are guaranteed to be safe, which this function sticks
   to, allowing it to be safe for a =before-save-hook=. (see [[http://whattheemacsd.com/buffer-defuns.el-01.html][this article]].)

   #+BEGIN_SRC emacs-lisp
     (defun jme:cleanup-buffer-safe ()
       "Perform a bunch of safe operations on the whitespace content of a buffer.
     Does not indent buffer, because it is used for a `before-save-hook', and that
     might be bad."
       (interactive)
       (untabify (point-min) (point-max))
       (delete-trailing-whitespace)
       (set-buffer-file-coding-system 'utf-8))
   #+END_SRC

   If we want to be less careful when cleaning up, we can do that too.

   #+BEGIN_SRC emacs-lisp
     (defun jme:cleanup-buffer ()
       "Perform a bunch of operations on the whitespace content of a buffer.
     Including indent-buffer, which should not be called automatically on save."
       (interactive)
       (jme:cleanup-buffer-safe)
       (indent-region (point-min) (point-max)))
   #+END_SRC

   Make sure we hook this into our save process.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'jme:cleanup-buffer-safe)
   #+END_SRC

** Movement

*** Better handling of move to beginning of line

    I find it useful to move to the beginning of the indentation as opposed
    to strickly the beginning of the line. This accomplishes that in a
    smart way. (See [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][this article]].)

    #+BEGIN_SRC emacs-lisp
      (defun jme:smarter-move-beginning-of-line (arg)
        "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to the beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.  If
      point reaches the beginning or end of the buffer, stop there."
        (interactive "^p")
        (setq arg (or arg 1))

        ;; Move lines first
        (when (/= arg 1)
          (let ((line-move-visual nil))
            (forward-line (1- arg))))

        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
            (move-beginning-of-line 1))))

      ;; remap C-a to `smarter-move-beginning-of-line'
      (global-set-key [remap move-beginning-of-line]
                      'jme:smarter-move-beginning-of-line)
    #+END_SRC

** Mark

   Mark handling when ~transient-mark-mode~ can be a little confusing when
   you want to set the mark but not engage /tmm/. ~Mastering Emacs~ has a
   good [[http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/][article]] on the subject.

   #+BEGIN_SRC emacs-lisp
     (defun jme:push-mark-no-activate ()
       "Pushes `point' to `mark-ring' and does not activate the region.
     Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
       (interactive)
       (push-mark (point) t nil)
       (message "Pushed mark to ring"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun jme:jump-to-mark ()
       "Jumps to the local mark, respecting the `mark-ring' order.
     This is the same as using \\[set-mark-command] with the prefix argument."
       (interactive)
       (set-mark-command 1))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun jme:exchange-point-and-mark-no-activate ()
       "Identical to \\[exchange-point-and-mark] but will not activate the region."
       (interactive)
       (exchange-point-and-mark)
       (deactivate-mark nil))
     (define-key global-map [remap exchange-point-and-mark] 'jme:exchange-point-and-mark-no-activate)
   #+END_SRC

* Theme Configuration

** Custom Themes

   I tend to like playing around with different color themes. Sometimes
   this is based on mood, sometimes it is based on environment. These
   themes go into their own directory.

   #+BEGIN_SRC emacs-lisp
     (setq custom-theme-directory (concat user-emacs-directory "themes"))
   #+END_SRC

   Support easy switching of themes via helm.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-themes
       :ensure t
       :after helm)
   #+END_SRC

** Fonts

   I have moved to using the =Adobe Source Code Pro= font. More information
   may be found on Source Code Pro can be found [[http://blog.typekit.com/2012/09/24/source-code-pro/][here]].

   Two separate fonts are possible, one for normal use and the other for
   use in presentation mode. Define some variables to hold them.

   #+BEGIN_SRC emacs-lisp
     (defvar jme:default-font (face-font 'default)
       "Default font to use.")
     (defvar jme:presentation-font (face-font 'default)
       "Font to use for presentations.")
   #+END_SRC

   Set appropriate fonts for the platform.

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (setq jme:default-font "-*-Source Code Pro-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
       (if (string-equal system-type "darwin")
         (setq jme:presentation-font "-*-Source Code Pro-normal-normal-normal-*-18-*-*-*-m-0-iso10646-1")
         (setq jme:presentation-font "-bitstream-bitstream vera sans mono-medium-r-*-*-*-120-*-*-*-*-*-*"))
       (set-face-attribute 'default nil :font jme:default-font))
   #+END_SRC

** Load custom theme

*** Org source blocks

    Color source blocks in org to make them stand out.

    See [[http://www.howardism.org/Technical/LP/dot-emacs.html][Howard Abrams Emacs Config]].

    #+BEGIN_SRC emacs-lisp
      (defun jme:org-src-color-blocks-light ()
        "Colors the block headers and footers to make them stand out more for lighter themes."
        (interactive)
        (custom-set-faces
         '(org-block-begin-line
          ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
         '(org-block-background
           ((t (:background "#FFFFEA"))))
         '(org-block-end-line
           ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))))

      (defun jme:org-src-color-blocks-dark ()
        "Colors the block headers and footers to make them stand out more for dark themes."
        (interactive)
        (custom-set-faces
         '(org-block-begin-line
           ((t (:foreground "#008ED1" :background "#002E41"))))
         '(org-block-background
           ((t (:background "#111111"))))
         '(org-block-end-line
           ((t (:foreground "#008ED1" :background "#002E41"))))))
    #+END_SRC

*** Presentation and Default theme

    Under certain situations, changing the theme is desirable, specifically
    when projecting on a larger screen. The following provides functions
    for switching themes. I have updated this to use the sanityinc versions
    of Chris Kempson's tommorow themes.

    Need to make sure to capture the default cursor color so we can switch
    it when appropriate.

    hide-mode-line provides a way for me to hide the mode line during
    presentations.

    #+BEGIN_SRC emacs-lisp
      (use-package material-theme
        :ensure t)

      (defun use-presentation-theme ()
       "Switch to presentation theme."
        (interactive)
        (load-theme 'material-light t)
        (when (boundp 'jme:presentation-font)
          (set-frame-font jme:presentation-font :frames nil)
          (set-face-attribute 'default nil :font jme:presentation-font))
        (setq default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))))

      (defun use-default-theme ()
       "Switch to the default theme."
        (interactive)
        (load-theme 'material t)
        (when (boundp 'jme:default-font)
          (set-frame-font jme:default-font :frames nil)
          (set-face-attribute 'default nil :font jme:default-font))
        (setq default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))))

      (defun toggle-presentation-mode ()
       "Toggle between presentation and default theme."
        (interactive)
        (if (string= (frame-parameter nil 'font) jme:default-font)
            (use-presentation-theme)
          (use-default-theme)))

      (use-default-theme)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package hide-mode-line)
    #+END_SRC

    For presentations themselves, provide org-present.

    #+BEGIN_SRC emacs-lisp
(use-package org-present
  :config (add-hook 'org-present-mode-hook
                    (lambda ()
                       (org-display-inline-images)
                       (hide-mode-line)
                       (use-presentation-theme)))
          (add-hook 'org-present-mode-quit-hook
                    (lambda ()
                       (org-remove-inline-images)
                       (use-default-theme)
                       (hide-mode-line))))
    #+END_SRC

** Spaceline

   Configure spaceline for mode-line theme.

   #+BEGIN_SRC emacs-lisp
     (use-package spaceline
       :ensure t
       :config
       (use-package spaceline-all-the-icons
         :ensure t
         :config
         (progn
           (dolist (s '((jme:spaceline-read-only "#4271AE" "Read only buffer face.")
                        (jme:spaceline-modified "#F36C60" "Modified buffer face.")
                        (jme:spaceline-unmodified "#78909C" "Unmodified buffer face.")))
             (eval `(defface ,(nth 0 s)
                      `((t (:background ,(nth 1 s)
                                        :foreground "#3E3D31"
                                        :inherit 'mode-line)))
                      ,(nth 2 s)
                      :group 'spaceline)))

           (defun jme:spaceline-highlight-face-modified ()
             "Set the highlight face depending on the buffer modified status.
              Set `spaceline-highlight-face-func' to
              `spaceline-highlight-face-modified' to use this."
             (cond
              (buffer-read-only 'jme:spaceline-read-only)
              ((buffer-modified-p) 'jme:spaceline-modified)
              (t 'jme:spaceline-unmodified)))

           (setq-default spaceline-highlight-face-func 'jme:spaceline-highlight-face-modified)
           (setq-default spaceline-all-the-icons-separator-type 'wave)
           (spaceline-toggle-all-the-icons-modified-on)
           (spaceline-toggle-all-the-icons-bookmark-off)
           (spaceline-toggle-all-the-icons-dedicated-off)
           (spaceline-toggle-all-the-icons-window-number-off)
           (spaceline-toggle-all-the-icons-eyebrowse-workspace-off)
           (spaceline-toggle-all-the-icons-buffer-size-on)
           (spaceline-toggle-all-the-icons-projectile-on)
           (spaceline-toggle-all-the-icons-mode-icon-on)
           (spaceline-toggle-all-the-icons-buffer-id-on)
           (spaceline-toggle-all-the-icons-buffer-path-off)
           (spaceline-toggle-all-the-icons-process-off)
           (spaceline-toggle-all-the-icons-position-on)
           (spaceline-toggle-all-the-icons-region-info-on)
           (spaceline-toggle-all-the-icons-fullscreen-off)
           (spaceline-toggle-all-the-icons-text-scale-on)
           (spaceline-toggle-all-the-icons-multiple-cursors-off)
           (spaceline-toggle-all-the-icons-narrowed-on)
           (spaceline-toggle-all-the-icons-vc-icon-off)
           (spaceline-toggle-all-the-icons-vc-status-on)
           (spaceline-toggle-all-the-icons-git-status-off)
           (spaceline-toggle-all-the-icons-git-ahead-off)
           (spaceline-toggle-all-the-icons-flycheck-status-on)
           (spaceline-toggle-all-the-icons-flycheck-status-info-off)
           (spaceline-toggle-all-the-icons-package-updates-off)
           (spaceline-toggle-all-the-icons-org-clock-current-task-off)
           (spaceline-toggle-all-the-icons-hud-off)
           (spaceline-toggle-all-the-icons-buffer-position-off)
           (spaceline-toggle-all-the-icons-battery-status-on)
           (spaceline-toggle-all-the-icons-time-on)
           (spaceline-toggle-all-the-icons-which-function-on)
           (spaceline-toggle-all-the-icons-temperature-off)
           (spaceline-toggle-all-the-icons-weather-off)
           (spaceline-toggle-all-the-icons-minor-modes-off)
           (spaceline-toggle-all-the-icons-nyan-cat-off)
           (spaceline-all-the-icons-theme))))
   #+END_SRC

* Key Bindings

  I have debated several times about where to locate key bindings. While
  there is a good argument to keeping them near the functions/configuration
  they relate to, I find it better to have all global keys in one place.

  | Key        | Action                      | Comments                            |
  |------------+-----------------------------+-------------------------------------|
  | =C-z=      | hide-or-expand              | Thought of as analog to shell sleep |
  | =M-`=      | jme:push-mark-no-activate   |                                     |
  | =C-`=      | pop-to-mark-command         |                                     |
  | =C-==      | expand-region               |                                     |
  | =C-c h=    | helm-mini                   |                                     |
  | =C-c n=    | jme:cleanup-buffer          | Destructive cleanup of buffer       |
  | =C-c on=   | jme:todays-daypage          | Open daypage for current day        |
  | =C-c oN=   | jme:find-daypage            | Open a specific day page            |
  | =C-c t=    | multi-term-next             | Reuse terminal                      |
  | =C-c T=    | multi-term                  | Create a new terminal               |
  | =C-c v p=  | git-messenger:popup-message | Popup the last git commit message   |
  | =C-x <up>= | jme:rotate-windows          | Rotates windows                     |
  | =C-. C-s=  | ace-jump-mode               |                                     |
  | =C-<f9>=   | toggle-presentation-mode    | switch in/out presentation theme    |

** Top-level mappings

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-z" 'hide-or-expand)

     (bind-key "M-`" 'jme:push-mark-no-activate)
     (bind-key "C-`" 'pop-to-mark-command)
   #+END_SRC

** =C-c= mappings

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c n" 'jme:cleanup-buffer)
     (bind-key "C-c on" 'jme:todays-daypage)
     (bind-key "C-c oN" 'jme:find-daypage)
   #+END_SRC

** =C-x= mappings

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x <up>" 'jme:rotate-windows)
   #+END_SRC

** Function Key mappings

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-<f9>" 'toggle-presentation-mode)
   #+END_SRC

* Emacs Server

   #+BEGIN_SRC emacs-lisp
     ;; Don't start the server unless we can verify that it isn't running.
     (use-package server
       :if (and window-system
                (not noninteractive))
       :config
       (when (and (functionp 'server-running-p) (not (server-running-p)))
          (server-start)))

     ;; Support for Chrome 'edit with emacs' extension
     (use-package edit-server
       :ensure t
       :if (and window-system
                (not noninteractive))
       :init
       (add-hook 'after-init-hook 'edit-server-start t))
   #+END_SRC

* Footer

  Add in the expected Emacs module footer.

  #+BEGIN_SRC emacs-lisp
    (provide 'init-ext)
    ;;; init-ext.el ends here
  #+END_SRC
