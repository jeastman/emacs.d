#+TITLE: Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+LATEX_CLASS: jmeorgdoc

* General Configuration

** Library Paths

Everything is situated underneath =user-emacs-directory (~/.emacs.d)=

This makes everything self-contained and easy to migrate to other
environments.

This section contains all of the path configurations that are not machine
specific. A seperate directory =(~/.emacs-meta)= is configured for =Meta=
information files (backups, temporary files, etc.)

*** Metafiles

First, we need to define the  =metafiles-dir= values.

#+BEGIN_SRC emacs-lisp
(setq metafiles-dir "~/.emacs-meta")
#+END_SRC

As this may be the first time I am running in this environment, the
=metafiles-dir= directory may not actually exist. We go ahead and create
it if it doesn't.

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p metafiles-dir)
  (make-directory metafiles-dir))
#+END_SRC

*** Temporary directory

I can now set the Emacs temporary directory to be within the
=metafiles-dir=, again creating it if necessary.

#+BEGIN_SRC emacs-lisp
(setq temporary-file-directory (concat metafiles-dir "/tmp/"))
(unless (file-exists-p temporary-file-directory)
  (make-directory temporary-file-directory))
#+END_SRC

** Package Management

I have moved /almost/ everything to use the package management system
instead of referencing external projects directly. This is extremely
convenient and makes updates very simple.

My Emacs packages are now managed by [[https://github.com/cask/cask][Cask]] and [[https://github.com/rdallasgray/pallet][Pallet]].

I maintain a list of the packages I am using here, but the actual list of
pacakges is managed in the =Cask= file. Pallet helps to ensure that the
packages installed are kept in sync with the dependency spec.

*** Packages

This list is a /mostly/ up-to-date list of the packages I use. Refer to the
=Cask= file for the list of packages actually installed.

| Package                 | Description                                                               |
|-------------------------+---------------------------------------------------------------------------|
| =ace-jump-mode=         | A quick cursor location minor mode                                        |
| =auto-complete=         | Auto completion                                                           |
| =coffee-mode=           | Major mode to edit CoffeeScript files                                     |
| =deferred=              | Simple asynchronous functions for emacs lisp                              |
| =deft=                  | quickly browse, filter, and edit plain text notes                         |
| =dired+=                | Extensions to Dired                                                       |
| =dired-details=         | make file details hide-able in dired                                      |
| =dired-details+=        | Enhancements to library `dired-details+.el'                               |
| =dired-single=          | Reuse the current dired buffer to visit another directory                 |
| =epc=                   | A RPC stack for the Emacs Lisp                                            |
| =expand-region=         | Increase selected region by semantic units                                |
| =git-gutter-fringe=     | Fringe version of git-gutter                                              |
| =graphviz-dot-mode=     | Mode for the dot-language used by graphviz                                |
| =handlebars-mode=       | A major mode for editing Handlebars files                                 |
| =helm=                  | An Emacs incremental and narrowing framework                              |
| =jabber=                | A Jabber client                                                           |
| =jedi=                  | a Python auto-completion for Emacs                                        |
| =js2-mode=              | Improved JavaScript editing mode                                          |
| =magit=                 | Control Git from Emacs                                                    |
| =markdown-mode=         | Major mode for Markdown-formatted text files                              |
| =markdown-mode+=        | extra functions for markdown-mode                                         |
| =multi-term=            | Managing multiple terminal buffers in Emacs                               |
| =nose=                  | Easy Python test running in Emacs                                         |
| =org=                   | Outline-based notes management and organizer                              |
| =powerline=             | Rewrite of Powerline                                                      |
| =pretty-mode=           | redisplay parts of the buffer as pretty symbols                           |
| =rainbow-delimiters=    | Highlight nested parens, brackets, braces a different color at each depth |
| =rainbow-mode=          | Colorize color names in buffers                                           |
| =sauron=                | Track (erc/org/dbus/...) events and react to them                         |
| =slime=                 | Superior Lisp Interaction Mode for Emacs                                  |
| =slime-js=              | Slime extension for swank-js                                              |
| =slime-repl=            | Read-Eval-Print Loop written in Emacs Lisp                                |
| =smex=                  | M-x interface with Ido-style fuzzy matching                               |
| =undo-tree=             | Treat undo history as a tree                                              |
| =w3m=                   | an Emacs interface to w3m                                                 |

** Additional Paths

I add the =user-emacs-directory= to the load path here to ensure we can pick up
the additional configuration files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path user-emacs-directory)
#+END_SRC

I also add all top-level subdirectories of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp
(let ((default-directory user-emacs-directory))
      (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

*** Paths for meta-information

I set up variables for all paths needed for storing things in the
=meta-information= directory. By consolidating them all in one place (and
using the variables later), I have an easier time keeping track of them
and maintaining them.

| Variable         | Purpose                                                                                                   |
|------------------+-----------------------------------------------------------------------------------------------------------|
| =meta-saveplace= | Name of the file that records the =save-place-alist=, which stores the location of point in visited files |
| =meta-backup=    | Location for backup files                                                                                 |
| =meta-bookmarks= | Bookmarks file.                                                                                           |
| =meta-savehist=  | File used by =savehist= where minibuffer history is save to and loaded                                    |
| =meta-recent=    | File to save the recent list into                                                                         |
| =meta-saves=     | Prefix to use for auto-save files                                                                         |
| =meta-ido=       | File in which the =ido= state is saved between invocations                                                |
| =meta-tramp=     | File used for =tramp= persistence                                                                         |

#+BEGIN_SRC emacs-lisp
(setq
   meta-saveplace (concat metafiles-dir "/saveplace")
   ;meta-backup (concat metafiles-dir "/backups/") ;; still needs work
   meta-bookmarks (concat metafiles-dir "/bookmarks")
   meta-savehist (concat metafiles-dir "/savehist")
   meta-recent (concat metafiles-dir "/recentf")
   meta-saves (concat metafiles-dir "/auto-save-list/.saves-")
   meta-ido (concat metafiles-dir "/ido.last")
   meta-tramp (concat metafiles-dir "/tramp"))
#+END_SRC

*** Non-packaged packages

There are several packages I use that do not exist in package archives. In
order to handle loading these, I add the 3rd party libraries in the
=vendor= directory.

#+BEGIN_SRC emacs-lisp
(setq vendor-dir (concat user-emacs-directory "vendor"))
(unless (file-exists-p vendor-dir)
  (make-directory vendor-dir))
(add-to-list 'load-path vendor-dir)
(let ((default-directory vendor-dir))
     (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

I leverage the =bind-key= package to do all of my key-binding. I need
to =require= it in early to handle all of my mode-specific key
bindings.

#+BEGIN_SRC emacs-lisp
(require 'bind-key)
#+END_SRC

*** System and user specific configuration

I run the same configuration on several machines. Different machines have
different capabilities as well as different file system layouts. To handle
this situation, I load system specific files based on the name of the
machine. I also load in a file based on user name, to handle additional
environments. I have updated my original version of this to do something
similar to what [[https://github.com/eschulte/emacs24-starter-kit][Emacs Starter Kit]] does by attempting to load several
different forms of each file.

#+BEGIN_SRC emacs-lisp
  (flet ((jme/load (base)
                   (let* ((path          (expand-file-name base user-emacs-directory))
                          (literate      (concat path ".org"))
                          (encrypted-org (concat path ".org.gpg"))
                          (plain         (concat path ".el"))
                          (encrypted-el  (concat path ".el.gpg")))
                     (cond
                      ((file-exists-p encrypted-org) (org-babel-load-file encrypted-org))
                      ((file-exists-p encrypted-el) (load encrypted-el))
                      ((file-exists-p literate) (org-babel-load-file literate))
                      ((file-exists-p plain) (load plain)))))
         (remove-extension (name)
             (string-match "\\(.*?\\)\.\\(org\\(\\.el\\)?\\|el\\)\\(\\.gpg\\)?$" name)
             (match-string 1 name)))
    (let ((user-dir (concat user-emacs-directory user-login-name)))
      (jme/load (car (split-string (system-name) "\\.")))
      (jme/load user-login-name)
      (when (file-exists-p user-dir)
          (add-to-list 'load-path user-dir)
          (mapc #'jme/load
                (remove-duplicates
                 (mapcar #'remove-extension
                         (directory-files user-dir t ".*\.\\(org\\|el\\)\\(\\.gpg\\)?$"))
                 :test #'string=)))))
#+END_SRC

** General Emacs Settings

There are a number of configuration items I tend to look at as basic
configuration. There is a fine line between what is a /package/ and what
is just part of Emacs, especially at the rate things are being included in
the /official/ distribution.

*** Window sizing

When using a =window-system=, which I most often do, I like to start Emacs
with a specific window size and position. This code accomplishes that.

First, we need to set up the window sizing.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (defvar emacs-min-top)
  (defvar emacs-min-left)
  (defvar emacs-min-height)
  (defvar emacs-min-width))

(if window-system
    (unless noninteractive
      (defvar emacs-min-top 22)
      (defvar emacs-min-left 5)
      (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
      (defvar emacs-min-width 100)))
#+END_SRC

This function resets the window to its minimal position.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-min ()
  (interactive)
  (set-frame-parameter (selected-frame) 'fullscreen nil)
  (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'top emacs-min-top)
  (set-frame-parameter (selected-frame) 'left emacs-min-left)
  (set-frame-parameter (selected-frame) 'height emacs-min-height)
  (set-frame-parameter (selected-frame) 'width emacs-min-width))
#+END_SRC

This function does the opposite of the above. It sets the window to
maximum position.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-max ()
  (interactive)
  (if t
      (progn
        (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
    (set-frame-parameter (selected-frame) 'top 26)
    (set-frame-parameter (selected-frame) 'left 2)
    (set-frame-parameter (selected-frame) 'width
                         (floor (/ (float (x-display-pixel-width)) 9.15)))
    (if (= 1050 (x-display-pixel-height))
        (set-frame-parameter (selected-frame) 'height
                             (if (>= emacs-major-version 24)
                                 66
                               55))
      (set-frame-parameter (selected-frame) 'height
                           (if (>= emacs-major-version 24)
                               75
                             64)))))
#+END_SRC

One last function to give me the ability to toggle between the two.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-toggle-size ()
  (interactive)
  (if (> (cdr (assq 'width (frame-parameters))) 100)
      (jme/emacs-min)
    (jme/emacs-max)))
#+END_SRC

I start off with Emacs in its minimal state when starting up. Since moving
to the =mac= Emacs port on my Apple machines, as opposed to the =ns=
version, I don't really use the toggle much anymore. Instead I use the mac
fullscreen mode.

#+BEGIN_SRC emacs-lisp
(if window-system
    (add-hook 'after-init-hook 'jme/emacs-min))
#+END_SRC

*** Coding system

I am a fan of UTF-8. Make sure everything is set up to handle it.

| Variable                     | Value   | Description          |
|------------------------------+---------+----------------------|
| =set-terminal-coding-system= | =utf-8= | terminal output      |
| =set-terminal-coding-system= | =utf-8= | terminal input       |
| =perfer-coding-system=       | =utf-8= | set preferred coding |

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

*** Interface settings

I most often have the audio on my machines muted, so use the visible bell
instead of beeps. Who likes beeps anyway?

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

Make sure I can see what it is that I am typing. This setting is the
number of seconds to pause before unfinished commands are echoed. I find
the default of 1 second a bit slow.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC

I am not a big fan of overloading the arrow keys. Plus they are just too
far away from my fingers to be useful. Don't use the shift+arrows for mark.

#+BEGIN_SRC emacs-lisp
(setq shift-select-mode nil)
#+END_SRC

Use point instead of click with mouse yank.

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC

While I no longer have a machine with a mouse connected (only trackpads
now), I still use swipe-type scrolling which I would like to be smooth.

These settings handle one line at a time, disable scrolling acceleration
and scroll the window under the mouse.

#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
(setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ; scroll window under mouse
#+END_SRC

Truncate lines in windows narrower than the frame.

#+BEGIN_SRC emacs-lisp
(setq truncate-partial-width-windows t)
#+END_SRC

Set the default tab stop.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

Never put tabs in files, use spaces instead. If, for some reason, a real
tab is needed, use =C-q C-i= to insert one.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

I want to always go to the next indent level when hitting return.

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
#+END_SRC

Add newlines to the end of the file if I naviagate past it.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)
#+END_SRC

Set the column that triggers fill

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 75)
#+END_SRC

Turn on auto fill for text files.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

Allow narrowing.

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-defun 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

*** Visual tweaks

Unlike a number of people, I do not mind the menu bar if I am actually
using a window system of some kind. It is not that I use it often, but it
does not get in my way much either. So, I check to see if I am using a
window system and disable it if not.

#+BEGIN_SRC emacs-lisp
(if (eq window-system 'nil)
    (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode 1)))
#+END_SRC

The toolbar, however, is completely useless to me, so I always disable it.

#+BEGIN_SRC emacs-lisp
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

Likewise, scrollbars offer no value.

#+BEGIN_SRC emacs-lisp
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Visually indicate empty lines after the buffer end. This is shown as a
fringe bitmap in the left edge.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
#+END_SRC

Cause Emacs to fully redraw the display before it processes queued input
events. Apparently this provides a slight performance tweak for newer
machines. My machines seem to be able to handle it. Picked up from
[[http://www.masteringemacs.org/articles/2011/10/02/improving-performance-emacs-display-engine/][here]]

#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t)
#+END_SRC

**** Modeline

I refer to my modeline quite often. It is very easy for it to get too
cluttered, it is expensive real estate.

Show the line:column number.

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Also, show the size of the file.

#+BEGIN_SRC emacs-lisp
(size-indication-mode 1)
#+END_SRC

***** Battery information

Battery information display in the modeline is controlled by
=battery-mode-line-format= and =battery-status-function=. I enable this
whenever I am on a mac, as I only have mac laptops.

=battery-mode-line-format= is a customizable variable, I am setting it here
to reflect the following format:

  - "âš¡ï¸Ž "
  - status
    - =empty= - high
    - =-= - low
    - =!= - critical
    - =+= - charging
  - load percentage
  - =%=
  - " " - a space
  - time remaining

The result should look something like:

=âš¡ï¸Ž 42% 2:30=

#+BEGIN_SRC emacs-lisp
  (if (string-equal system-type "darwin")
      (setq battery-mode-line-format "âš¡ï¸%b%p%% %t ")
    (setq battery-mode-line-format "âš¡ï¸Ž %b%p%%%% %t "))
  (display-battery-mode)
#+END_SRC

***** Time

I often run emacs in a fullscreen fashion that does not display the system
clock on my desktop. However, I often refer to the clock, thus I add it to
the modeline. The =display-time= functionality in Emacs is quite robust and
can potentially display much more information than just the time. I
configure it here to my liking.

#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average nil)  ; Don't display load
  (setq display-time-day-and-date nil)  ; Don't display date
  (if (string-equal system-type "darwin")
      (setq display-time-format "ðŸ•—%l:%M%p")
    (setq display-time-format "%l:%M%p"))
  (display-time-mode)
#+END_SRC

*** Miscellaneous

Add newline to end of file on save.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Make Emacs use the clipboard

#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
#+END_SRC

Seed the random-number generator

#+BEGIN_SRC emacs-lisp
(random t)
#+END_SRC

Prefix used for generating the auto save file names.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix meta-saves)
#+END_SRC

**** Bookmarks

Save bookmarks into their own file in the meta information directory.

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file meta-bookmarks)
#+END_SRC

**** Backup

I like all of my backup copies of files to be in a common location.

Configure where the backups should go.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (quote ((".*" . "~/.emacs-meta/backups/"))))
#+END_SRC

I like to use version numbers for the backup files. Set the number of
newest versions and oldest versions to keep when a new numbered backup is
made. I also don't care about the deletion of excess backup versions, so do
that silently. Also, I like to use copying to create backups for files
that are linked, instead of renaming.

| Variable                        | Value | Description                                                          |
|---------------------------------+-------+----------------------------------------------------------------------|
| =version-control=               | =t=   | Control use of version numbers for backup files                      |
| =kept-new-versions=             | =2=   | Number of newest versions to keep when a new numbered backup is made |
| =kept-old-versions=             | =2=   | Number of oldest versions to keep when a new numbered backup is made |
| =delete-old-versions=           | =t=   | When set to =t=, delete excess backup versions silently              |
| =backup-by-copying-when-linked= | =t=   | Use copying to create backups for files with multiple names          |

#+BEGIN_SRC emacs-lisp
(setq
  version-control t
  kept-new-versions 2
  kept-old-versions 2
  delete-old-versions t
  backup-by-copying-when-linked t)
#+END_SRC

*** Global mode settings

**** Auto-revert

Revert buffers when they change on disk.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Auto-refresh dired buffers.

#+BEGIN_SRC emacs-lisp
(setq global-auto-revert-non-file-buffers t)
#+END_SRC

But.. don't announce reversion of buffer

#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
#+END_SRC

**** Git gutter

Git gutter is a nice little utility that adds markers in the fringe to
denote changes in a file.

#+BEGIN_SRC emacs-lisp
(require 'git-gutter-fringe)
(setq git-gutter:lighter " GG")
#+END_SRC

Turn it on globally.

#+BEGIN_SRC emacs-lisp
(global-git-gutter-mode t)
#+END_SRC

**** Recentf
b
Save recently used files. This turns on the "Open Recent" submenu which is
displayed in the "File" menu, containing a list of files that were
operated on recently.

Require the actual package.

#+BEGIN_SRC emacs-lisp
(require 'recentf)
#+END_SRC

I use the following settings for this mode:

| variable                 | value         | description                       |
|--------------------------+---------------+-----------------------------------|
| =recentf-save-file=      | =meta-recent= | File to save the recent list into |
| =recent-max-saved-items= | 100           | Max number of items saved         |
| =recent-max-menu-items=  | 15            | Max number of items in menu       |

#+BEGIN_SRC emacs-lisp
(setq
  recentf-save-file meta-recent
  recentf-max-saved-items 100
  recentf-max-menu-items 15)
#+END_SRC

Turn on Recentf mode.

#+BEGIN_SRC emacs-lisp
(recentf-mode t)
#+END_SRC

**** Savehist

Save minibuffer history. The minibuffer history is saved periodically
(every 300 seconds, in this case) and when exiting Emacs. I use
=savehist-file= to specify the filename (in the meta information directory)
where the history should be stored. Additionally, I have it set to save:

| History type         | Description                                        |
|----------------------+----------------------------------------------------|
| =search-ring=        | List of search string sequences                    |
| =regexp-search-ring= | List of regular expression search string sequences |

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables
  '(search-ring regexp-search-ring)
  savehist-autosave-interval 300
  savehist-file meta-savehist)
#+END_SRC

Turn on savehist minor mode.

#+BEGIN_SRC emacs-lisp
(savehist-mode t)
#+END_SRC

**** Saveplace

Preserve the location of point in file when saving files.

Specify the name of the file that records saveplace information.

#+BEGIN_SRC emacs-lisp
(setq save-place-file meta-saveplace)
#+END_SRC

Activate saveplace for all buffers.

#+BEGIN_SRC emacs-lisp
(setq-default save-place t)
#+END_SRC

Require the actual package.

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
#+END_SRC

**** Show Paren mode

I like to visually see the matching parens. =Show Paren= mode is a global
minor mode that highlights matching parens. I have now replaced the
original =show paren= with =smartparens=.

#+BEGIN_SRC emacs-lisp
(smartparens-global-mode t)
(show-smartparens-global-mode t)
#+END_SRC

**** Undo-tree-mode

=Undo-tree-mode= replaces Emacs' standard undo feature with a more
powerful, yet easier to user version, that treats the undo history as what
it is: a tree.

Enable =Undo-tree-mode= globally.

#+BEGIN_SRC emacs-lisp
(global-undo-tree-mode)
#+END_SRC

**** Whitespace

I like to see whitespace in files. I find this helps with both
organization and formatting. I use the following style for whitespace
visualization:

| Style            | Description                           |
|------------------+---------------------------------------|
| face             | enable all visualization via faces    |
| trailing         | trailing blanks                       |
| space-before-tab | SPACEs before TAB                     |
| space-after-tab  | 8 or more SPACEs after a TAB          |
| indentation      | 8 or more SPACEs at beginning of line |

#+BEGIN_SRC emacs-lisp
(setq whitespace-style '(face trailing space-before-tab
                   indentation space-after-tab))
#+END_SRC

Specify the column beyond which the line is highlighted.

#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column 80)
#+END_SRC

Turn on whitespace visualization minor mode globally.

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode 1)
#+END_SRC

**** Winner

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

* Utility functions

There are a number of /utility/ functions that I keep around for handling
different things. Some of them are experimental, but they /do/ work.

** Hide or Expand

I have kept this around for a long time and go through different phases
of using it. I have recently gone back to using it quite a bit now that I
have been using =winner= mode.

#+BEGIN_SRC emacs-lisp
(defun hide-or-expand ()
  (interactive)
  (if (> (length (window-list)) 1)
      (delete-other-windows)
    (bury-buffer)))
#+END_SRC

** Mark and Pop

This bit of elisp allows optionally storing the mark before moving. I
adopted this from a [[https://gist.github.com/magnars/2350388][gist]] by Magnar Sveen.

#+BEGIN_SRC emacs-lisp
(defvar push-mark-before-goto-char nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice goto-char (before push-mark-first activate)
  (when push-mark-before-goto-char
    (push mark)))
#+END_SRC

* Package Specific Settings

** Auto complete

I have fiddled around with different auto-completion packages and
extensions over time. This one works.

#+BEGIN_SRC emacs-lisp
(when (require 'auto-complete-config nil 'noerror)
  (ac-config-default)
  (setq ac-user-dictionary-files (concat metafiles-dir "/.dict"))
  (setq ac-comphist-file (concat metafiles-dir "/ac-comphist.dat"))
  (bind-key "S-TAB" 'auto-complete ac-mode-map))
#+END_SRC

** YASnippet

YASnippet is an excellent template system for Emacs and it works very well
with Auto Complete. I use it everywhere I can.

#+BEGIN_SRC emacs-lisp
(yas-global-mode 1)
#+END_SRC

** CoffeeScript

Support for CoffeeScript.

#+BEGIN_SRC emacs-lisp
(when (require 'coffee-mode nil 'noerror)

  (defun coffee-custom ()
    "coffee-mode-hook"

    ;; CoffeeScript uses two spaces.
    (set (make-local-variable 'tab-width) 2)

    ;; If you don't have js2-mode
    (setq coffee-js-mode 'javascript-mode)

    ;; If you don't want your compiled files to be wrapped
    (setq coffee-args-compile '("-c" "--bare"))

    ;; *Messages* spam
    (setq coffee-debug-mode t)

    ;; Emacs key binding
    (define-key coffee-mode-map [(meta r)] 'coffee-compile-buffer)

    ;; Compile '.coffee' files on every save
    (and (file-exists-p (buffer-file-name))
         (file-exists-p (coffee-compiled-file-name))
         (coffee-cos-mode t)))

  (add-hook 'coffee-mode-hook 'coffee-custom))
#+END_SRC

** Deft

I find Deft to be a great note-taking utility.

#+BEGIN_SRC emacs-lisp
(when (require 'deft nil 'noerror)
  (when (boundp 'my-notes)
    (when (file-exists-p my-notes)
      (setq
       deft-extension "org"
       deft-directory my-notes
       deft-text-mode 'org-mode)
      (bind-key "<f9>" 'deft))))
#+END_SRC

** Dired

I have been trying to train myself to use =dired= as much as possible. My
go-to alternative is the command line, which often interrupts whatever I
was doing in the particular shell I choose. My settings here are still
very much experimental.

I moved to using =dired+= to pick up some extra features.

#+BEGIN_SRC emacs-lisp
(require 'dired+)
(put 'dired-find-alternate-file 'disabled nil)  ;enable `a' command


;; Make dired less verbose
(require 'dired-details)
;;(setq-default dired-details-hidden-string "--- ")
(dired-details-install)

(when (require 'dired-single nil 'noerror)

  ;Make sure each dired buffer doesn't spawn new dired buffers
  (defun my-dired-init ()
    "Bunch of stuff to run for dired, either immediately or when it's
  loaded."
    ;; <add other stuff here>
    (define-key dired-mode-map [return] 'dired-single-buffer)
    (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse)
    (define-key dired-mode-map "^"
      (function
       (lambda nil (interactive) (dired-single-buffer "..")))))
  ;; if dired's already loaded, then the keymap will be bound
  (if (boundp 'dired-mode-map)
      ;; we're good to go; just add our bindings
      (my-dired-init)
    ;; it's not loaded yet, so add our bindings to the load-hook
    (add-hook 'dired-load-hook 'my-dired-init)))
#+END_SRC

Make sure =image-dired= keeps its files in the meta directory.

#+BEGIN_SRC emacs-lisp
(setq image-dired-dir (concat metafiles-dir "/image-dired"))
#+END_SRC

** Erlang

#+BEGIN_SRC emacs-lisp
(require 'erlang-start nil 'noerror)
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

** Flyspell

I often use =flyspell= mode when writing text documents. I typically turn
this on a some point after I have already begun writing. This bit of
advice ensures that the buffer is checked when I turn =flyspell= on.

#+BEGIN_SRC emacs-lisp
(defadvice flyspell-mode (after advice-flyspell-check-buffer-on-start activate)
  (flyspell-buffer))
#+END_SRC

** Guide Key

Nice utility for providing a guide for key bindings.

#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence '("C-x"))
(guide-key-mode 1)
(setq guide-key/recursive-key-sequence-flag t)
(setq guide-key/popup-window-position 'bottom)

#+END_SRC

** Haskell

I like automatic indentation, needs to be turned on for Haskell.

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
#+END_SRC

Show documentation.

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
#+END_SRC

Ignore compiled Haskell files in filename completions.

#+BEGIN_SRC emacs-lisp
(add-to-list 'completion-ignored-extensions ".hi")
#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp
(when (package-installed-p 'helm)
  (require 'helm-misc)
  (bind-key "C-c M-x" 'helm-M-x)
  (bind-key "C-h a" 'helm-apropos)
  (bind-key "M-s a" 'helm-do-grep)
  (bind-key "M-s b" 'helm-occur)
  (bind-key "M-s F" 'helm-for-files))
#+END_SRC

** Ido

Provide an easy way to load a recent file utilizing ido.

#+BEGIN_SRC emacs-lisp
  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
        (find-file file))))
#+END_SRC

Configure ido to use vertical mode. Much easier to see matches.

#+BEGIN_SRC emacs-lisp
(ido-vertical-mode)
#+END_SRC

Use ido everywhere.

#+BEGIN_SRC emacs-lisp
(ido-ubiquitous-mode 1)
#+END_SRC

*** Configuration

These settings control the behavior of ido.

| Setting                              | Value      | Description                                        |
|--------------------------------------+------------+----------------------------------------------------|
| =ido-case-fold=                      | =t=        | Ignore case when searching                         |
| =ido-confirm-unique-completion=      | =t=        | wait for RET, even with unique completion          |
| =ido-create-new-buffer=              | =always=   | Always create new buffers unconditionally          |
| =ido-enable-flex-matching=           | =t=        | Use flexible string matching                       |
| =ido-enable-last-directory-history=  | =t=        | Remember latest selected directory name            |
| =ido-max-prospects=                  | =10=       | Limit prospect list to 10 values                   |
| =ido-max-work-directory-list=        | =30=       | Maximum number of working directories to record    |
| =ido-max-work-file-list=             | =50=       | Maximum number of names of recently opened files   |
| =ido-save-directory-list-file=       | =meta-ido= | File used to store ido state                       |
| =ido-use-filename-at-point=          | =nil=      | Don't attempt to use filename at point as starting point |
| =ido-use-url-at-point=               | =nil=      | Don't attempt to use URL at point                  |
| =confirm-nonexistent-file-or-buffer= | =nil=      | Don't confirm before visiting a non-existent file  |

#+BEGIN_SRC emacs-lisp
  (require 'flx-ido)
  (ido-mode t)
  (setq
   ido-case-fold  t                 ; be case-insensitive
   ido-confirm-unique-completion t  ; wait for RET, even with unique completion
   ido-create-new-buffer 'always
;   ido-enable-flex-matching t
   ido-enable-last-directory-history t ; remember last used dirs
   ido-max-prospects 10
   ido-max-work-directory-list 30   ; should be enough
   ido-max-work-file-list      50   ; remember many
   ido-save-directory-list-file meta-ido
   ido-use-filename-at-point nil
   ido-use-url-at-point nil
   ido-everywhere 1
   flx-ido-mode 1
  )

  (setq confirm-nonexistent-file-or-buffer nil)

  ;; increase minibuffer size when ido completion is active
  (add-hook 'ido-minibuffer-setup-hook
    (function
      (lambda ()
        (make-local-variable 'resize-minibuffer-window-max-height)
        (setq resize-minibuffer-window-max-height 1))))
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp
(when (require 'js-comint nil 'noerror)
  (setq inferior-js-program-command "node"))
#+END_SRC

** LaTeX

Configure AUCTeX to automatically save style information when saving the
buffer and to parse the file after loading to get style information.

Also, query for the name of the master file.

#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)
#+END_SRC

** Lisp

#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
(add-hook 'emacs-lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(require 'magit nil 'noerror)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(when (require 'markdown-mode nil 'noerror)
  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode)))
#+END_SRC

** Newsticker

#+BEGIN_SRC emacs-lisp
(setq newsticker-cache-filename (concat metafiles-dir "/.newsticker-cache"))
(setq newsticker-dir (concat metafiles-dir "/newsticker/"))
(setq-default
   newsticker-automatically-mark-items-as-old nil
   newsticker-automatically-mark-visited-items-as-old t
   newsticker-obsolete-item-max-age (* 30 (* 24 3600))
   newsticker-hide-immortal-items-in-echo-area t
   newsticker-hide-obsolete-items-in-echo-area t
   newsticker-html-renderer 'w3m-region
   newsticker-date-format "(%A, %B %d %I:%M%p)")
#+END_SRC

** Org

My =org= mode settings are contained in their own file. This function
loads the configuration based on my login name.

#+BEGIN_SRC emacs-lisp
(let* ((path (expand-file-name (concat user-login-name "-org") user-emacs-directory))
        (literate (concat path ".org")))
     (cond
      ((file-exists-p literate) (org-babel-load-file literate))))
#+END_SRC

** Pianobar

#+BEGIN_SRC emacs-lisp
(autoload 'pianobar "pianobar" nil t)
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
(setq python-remove-cwd-from-path nil)

; Bring back indent after newline
(add-hook 'python-mode-hook '(lambda ()
             (define-key python-mode-map "\C-m" 'newline-and-indent)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Jedi for Python
(eval-when-compile (require 'jedi nil t))
(setq jedi:setup-keys t)
(add-hook 'python-mode-hook 'jedi:setup)
#+END_SRC

** Rainbow mode

#+BEGIN_SRC emacs-lisp
(when (require 'rainbow-mode nil 'noerror)
  (add-hook 'css-mode-hook 'rainbow-mode))
#+END_SRC

** Shell

I try to use my shell within Emacs as much as possible. I will admit that
I have not yet been able to do this completely, though the desire is
there.

#+BEGIN_SRC emacs-lisp
(require 'comint)
#+END_SRC

Ensure that the shell prompt is read only, not doing this is just weird.

#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only t)
#+END_SRC

Update the mode's keybindings to work to my liking.

#+BEGIN_SRC emacs-lisp
(define-key comint-mode-map [(meta p)]
   'comint-previous-matching-input-from-input)
(define-key comint-mode-map [(meta n)]
   'comint-next-matching-input-from-input)
(define-key comint-mode-map [(control meta n)]
    'comint-next-input)
(define-key comint-mode-map [(control meta p)]
    'comint-previous-input)
#+END_SRC

Ensure the shell is set to UTF-8.

#+BEGIN_SRC emacs-lisp
(add-hook 'term-exec-hook
          (function
           (lambda ()
             (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
#+END_SRC

Autoload =multi-term= and =multi-term-next= so they can be used in key
bindings.

#+BEGIN_SRC emacs-lisp
(autoload 'multi-term "multi-term" nil t)
(autoload 'multi-term-next "multi-term" nil t)
#+END_SRC

Tramp is a fantastic package that allows for remote file editing.

#+BEGIN_SRC emacs-lisp
(require 'tramp)
#+END_SRC

I provide a regexp to match my prompts.

#+BEGIN_SRC emacs-lisp
(setq shell-prompt-pattern "^[^a-zA-Z].*[#$%>â˜ž] *")
#+END_SRC

Set Tramp to use ssh by default.

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC

Have Tramp store its files in the meta information directory.

#+BEGIN_SRC emacs-lisp
(setq tramp-persistency-file-name meta-tramp)
#+END_SRC

** Smex

#+BEGIN_SRC emacs-lisp
(setq smex-save-file (concat metafiles-dir "/.smex-items"))
(smex-initialize)
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

** Swank-js

#+BEGIN_SRC emacs-lisp
(when (package-installed-p 'slime-js)
  (add-hook 'js2-mode-hook
            (lambda ()
              (slime-js-minor-mode 1)))
  (add-hook 'css-mode-hook
            (lambda ()
              (define-key css-mode-map "\M-\C-x" 'slime-js-refresh-css)
              (define-key css-mode-map "\C-c\C-r" 'slime-js-embed-css))))
#+END_SRC

** Uniquify

By default, Emacs makes buffer names unique by adding =<2>=, =<3>=,
etc. to the end of the buffer name. I don't find this particularly
useful. Using the =Uniquify= package, I can easily change this behavior.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
#+END_SRC

Use the =post-forward= type of naming for buffers. This names the buffer
with the file name followed by a shortened form of the path.

For example:

=/foo/bar/mumble/name= becomes =name|bar/mumble=

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'post-forward)
#+END_SRC

Change the string used as a separator for the buffer name components.

#+BEGIN_SRC emacs-lisp
(setq uniquify-separator ":")
#+END_SRC

Rerationalize buffer names after a buffer has been killed.

#+BEGIN_SRC emacs-lisp
(setq uniquify-after-kill-buffer-p t)
#+END_SRC

Some buffers should not be uniquified. I provide a regular expression here
for these exceptions.

#+BEGIN_SRC emacs-lisp
(setq uniquify-ignore-buffers-re "^\\*")
#+END_SRC

** w3m

#+BEGIN_SRC emacs-lisp
(setq w3m-use-cookies t)
#+END_SRC

** Diminish

I use diminish to hide most of minor modes from the modeline.

#+BEGIN_SRC emacs-lisp
(eval-after-load "auto-complete" '(diminish 'auto-complete-mode))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(eval-after-load "flymake" '(diminish 'flymake-mode))
(eval-after-load "git-gutter" '(diminish 'git-gutter-mode))
(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "smartparens" '(diminish 'smartparens-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "whitespace" '(diminish 'global-whitespace-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
#+END_SRC

* Custom Configuration

** Window handling

*** Rotating Windows

I often have my frame split into multiple windows. I find it very handy to
swap buffers between windows if I am working in multiple buffers at the
same time. I came across this function to rotate buffers through windows
(you can find it [[http://whattheemacsd.com/buffer-defuns.el-02.html][here]].)

#+BEGIN_SRC emacs-lisp
  (defun jme/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond ((not (> (count-windows)1))
           (message "You can't rotate a single window!"))
          (t
           (setq i 1)
           (setq numWindows (count-windows))
           (while  (< i numWindows)
             (let* (
                    (w1 (elt (window-list) i))
                    (w2 (elt (window-list) (+ (% i numWindows) 1)))
                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))
                    (s1 (window-start w1))
                    (s2 (window-start w2))
                    )
               (set-window-buffer w1  b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i (1+ i)))))))
#+END_SRC

*** Window Split

This function toggles between horizontal and vertical layout of two
windows. (Picked up from [[http://whattheemacsd.com/buffer-defuns.el-03.html][here]].)

#+BEGIN_SRC emacs-lisp
(defun jme/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

** Cleanup

Whitespace cleanup can be dangerous if it changes the content of the
file. Some changes are guaranteed to be safe, which this function sticks
to, allowing it to be safe for a =before-save-hook=. (see
[[http://whattheemacsd.com/buffer-defuns.el-01.html][this article]].)

#+BEGIN_SRC emacs-lisp
(defun jme/cleanup-buffer-safe ()
  "Perform a bunch of safe operations on the whitespace content of a buffer.
Does not indent buffer, because it is used for a before-save-hook, and that
might be bad."
  (interactive)
  (untabify (point-min) (point-max))
  (delete-trailing-whitespace)
  (set-buffer-file-coding-system 'utf-8))
#+END_SRC

If we want to be less careful when cleaning up, we can do that too.

#+BEGIN_SRC emacs-lisp
(defun jme/cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (jme/cleanup-buffer-safe)
  (indent-region (point-min) (point-max)))
#+END_SRC

** Movement

*** Better handling of move to beginning of line

I find it useful to move to the beginning of the indentation as opposed to
strickly the beginning of the line. This accomplishes that in a smart
way. (See
[[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][this article]].)

#+BEGIN_SRC emacs-lisp
  (defun jme/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'jme/smarter-move-beginning-of-line)
#+END_SRC

** Mark

Mark handling when ~transient-mark-mode~ can be a little confusing when you
want to set the mark but not engage /tmm/. ~Mastering Emacs~ has a good
[[http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/][article]] on the subject.

#+BEGIN_SRC emacs-lisp
(defun jme/push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jme/jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jme/exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(define-key global-map [remap exchange-point-and-mark] 'jme/exchange-point-and-mark-no-activate)
#+END_SRC

* Theme Configuration

** Custom Themes

I tend to like playing around with different color themes. Sometimes this
is based on mood, sometimes it is based on environment. These themes go
into their own directory.

#+BEGIN_SRC emacs-lisp
  (setq custom-theme-directory (concat user-emacs-directory "themes"))
#+END_SRC

** Fonts
I have moved to using the =monoOne= font. More information may be found on
monoOne [[https://github.com/madmalik/monoOne][here]].

Set appropriate fonts for the platform.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (setq jme/default-font "-*-monoOne-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
    (if (string-equal system-type "darwin")
        (setq jme/presentation-font "-apple-Monaco-medium-normal-normal-*-28-*-*-*-m-0-iso10646-1")
      (setq jme/presentation-font "-bitstream-bitstream vera sans mono-medium-r-*-*-*-120-*-*-*-*-*-*"))
    (set-face-attribute 'default nil :font jme/default-font))
#+END_SRC

** Load custom theme

For certain major modes, I find it desirable to use a non-monospaced
font. Typically this is for certain documentation modes where the end
result will not end up in a monospaced font. (I picked up this particular
code from a [[ehttp://stackoverflow.com/questions/534307/set-emacs-defaut-font-face-per-buffer-mode/3756010#3756010][stackoverflow question]].

#+BEGIN_SRC emacs-lisp
(dolist (hook '(erc-mode-hook
        org-mode-hook
        markdown-mode-hook))
  (add-hook hook (lambda () (variable-pitch-mode t))))
#+END_SRC

Under certain situations, changing the theme is desirable, specifically
when projecting on a larger screen. The following provides functions for
switching themes.

#+BEGIN_SRC emacs-lisp
(defun use-presentation-theme ()
  (interactive)
  (if (string-equal system-type "darwin")
      (disable-theme 'tomorrow-night-mac)
    (disable-theme 'tomorrow-night))
  (load-theme 'prez t)
  (when (boundp 'jme/presentation-font)
    (set-face-attribute 'default nil :font jme/presentation-font)))

(defun use-default-theme ()
  (interactive)
  (disable-theme 'prez)
  (if (string-equal system-type "darwin")
      (load-theme 'tomorrow-night-mac t)
    (load-theme 'tomorrow-night t))
  (when (boundp 'jme/default-font)
    (set-face-attribute 'default nil :font jme/default-font)))

(defun toggle-presentation-mode ()
  (interactive)
  (if (string= (frame-parameter nil 'font) jme/default-font)
      (use-presentation-theme)
    (use-default-theme)))

(use-default-theme)
#+END_SRC

** Monkey Mode Line

My own invention of a mode line layout.

#+BEGIN_SRC emacs-lisp
(require 'monkey-mode-line)
(monkeyml/monkey-mode-line)
#+END_SRC

** Powerline

Turn on powerline for modeline goodness. Soon to be disabled in favor of
Monkey Mode Line.

I like the look of powerline, but I wanted battery status displayed, which
it did not do so well. This updated theme adds that by moving the
positioning stuff over more to the left and adding the
=global-mode-string= into its own section. When nothing is set in that
portion, it remains empty.

The modeline is broken into two sides, left and right.

*** The left hand side

The left hand side is composed of:

  - Left side
    - Buffer status
      - =%= - read only
      - =*= - modified
      - =-= - not modified
    - Buffer size
    - mode-line-mule-info
    - Buffer identification
    - 'Which function' name
    - " " - a space
  - Powerline Separator
    - ERC Modified Channels
    - Major mode
    - Process
    - Minor modes
    - Narrow
    - " " - a space
  - Powerline Separator
    - VC mode

*** The right hand side

  - Powerline Separator
    - " " - a space
    - line number
    - ':'
    - column number
    - Buffer Percentage
  - Powerline Separator
    - global-mode-string
      - Battery and Time information

*** The theme itself

#+BEGIN_SRC emacs-lisp
  (defun jme/powerline-theme ()
    "Setup personal powerline theme."
    (interactive)
    (setq-default mode-line-format
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (mode-line (if active 'mode-line 'mode-line-inactive))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (separator-left (intern (format "powerline-%s-%s"
                                                            powerline-default-separator
                                                            (car powerline-default-separator-dir))))
                            (separator-right (intern (format "powerline-%s-%s"
                                                             powerline-default-separator
                                                             (cdr powerline-default-separator-dir))))
                            (lhs (list (powerline-raw "%*" nil 'l)
                                       (powerline-buffer-size nil 'l)
                                       (powerline-raw mode-line-mule-info nil 'l)
                                       (powerline-buffer-id nil 'l)
                                       (when (and (boundp 'which-func-mode) which-func-mode)
                                         (powerline-raw which-func-format nil 'l))
                                       (powerline-raw " ")
                                       (funcall separator-left mode-line face1)
                                       (when (boundp 'erc-modified-channels-object)
                                         (powerline-raw erc-modified-channels-object face1 'l))
                                       (powerline-major-mode face1 'l)
                                       (powerline-process face1)
                                       (powerline-minor-modes face1 'l)
                                       (powerline-narrow face1 'l)
                                       (powerline-raw " " face1)
                                       (funcall separator-left face1 face2)
                                       (powerline-vc face2 'r)))
                            (rhs (list (funcall separator-right face2 face1)
                                       (powerline-raw " " face1)
                                       (powerline-raw "%4l" face1 'l)
                                       (powerline-raw ":" face1 'l)
                                       (powerline-raw "%3c" face1 'r)
                                       (powerline-raw "%6p" face1 'r)
                                       (funcall separator-right face1 mode-line)
                                       (powerline-raw " ")
                                       (powerline-raw global-mode-string nil 'l))))
                       (concat (powerline-render lhs)
                               (powerline-fill face2 (powerline-width rhs))
                               (powerline-render rhs)))))))

  ;(jme/powerline-theme)
#+END_SRC

* Key Bindings

I have debated several times about where to locate key bindings. While
there is a good argument to keeping them near the functions/configuration
they relate to, I find it better to have all global keys in one place.

| Key        | Action                      | Comments                            |
|------------+-----------------------------+-------------------------------------|
| =C-z=      | hide-or-expand              | Thought of as analog to shell sleep |
| =M-`=      | jme/push-mark-no-activate   |                                     |
| =C-`=      | pop-to-mark-command         |                                     |
| =C-==      | expand-region               |                                     |
| =C-c h=    | helm-mini                   |                                     |
| =C-c n=    | jme/cleanup-buffer          | Destructive cleanup of buffer       |
| =C-c t=    | multi-term-next             | Reuse terminal                      |
| =C-c T=    | multi-term                  | Create a new terminal               |
| =C-c w=    | jme/emacs-toggle-size       | Custom function for min/max size    |
| =C-c v p=  | git-messenger:popup-message | Popup the last git commit message   |
| =C-x <up>= | jme/rotate-windows          | Rotates windows                     |
| =C-. C-s=  | ace-jump-mode               |                                     |
| =C-<f9>=   | toggle-presentation-mode    | switch in/out presentation theme    |

** Top-level mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'hide-or-expand)

(bind-key "M-`" 'jme/push-mark-no-activate)
(bind-key "C-`" 'pop-to-mark-command)

(when (package-installed-p 'expand-region)
    (bind-key "C-=" 'er/expand-region))
#+END_SRC

** =C-c= mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-c h" 'helm-mini)
(bind-key "C-c n" 'jme/cleanup-buffer)
(bind-key "C-c t" 'multi-term-next)
(bind-key "C-c T" 'multi-term)
(bind-key "C-c w" 'jme/emacs-toggle-size)
(bind-key "C-x v p" 'git-messenger:popup-message)
#+END_SRC

** =C-x= mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-x <up>" 'jme/rotate-windows)
#+END_SRC

** =C-.= mappings

#+BEGIN_SRC emacs-lisp
(when (package-installed-p 'ace-jump-mode)
    (bind-key "C-. C-s" 'ace-jump-mode))
#+END_SRC

** Function Key mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-<f9>" 'toggle-presentation-mode)
#+END_SRC

* Custom Settings

Keep emacs Custom-settings in separate file.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+END_SRC

* Emacs Server

#+BEGIN_SRC emacs-lisp
;; Don't start the server unless we can verify that it isn't running.
(require 'server)
(when (and (functionp 'server-running-p) (not (server-running-p)))
(server-start))

;; Support for Chrome 'edit with emacs' extension
(when (require 'edit-server nil 'noerror)
  (edit-server-start))
#+END_SRC
