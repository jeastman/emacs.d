#+TITLE: Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+LATEX_CLASS: jmeorgdoc

* Reworking Configuration

  I recently read a [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][post]] by Sebastian Wiesner regarding the use of
  =use-package= that got me curious enough to attempt to rework my Emacs
  configuration. I now attempt to utilize =use-package= for all of the
  packages I use. Check John Wiegley's [[https://github.com/jwiegley/use-package/][Github Page]] for more details.

  I previously used =Cask= and =Pallet= to manage all of my packages, which
  worked quite well, but did not address the configuration side of
  things. Moving forward, I am likely to use a combination of the two.

* File Header

Add some comments to the beginning of the generated elisp file.

#+BEGIN_SRC emacs-lisp :padline no
  ;;; init-ext.el -- Automatically generated initialization file
  ;;;
  ;;; This file is generated based on the init-ext.org file.
  ;;; Please see that file for complete documentation.
  ;;;
  ;;; Commentary:
  ;;; See init-ext.org
  ;;;
  ;;; Code:
  ;;;

#+END_SRC

* General Configuration
** Exec path

   Ensure that =/usr/local/bin= is in the exec path.

   #+BEGIN_SRC emacs-lisp
   (when (not (member "/usr/local/bin" exec-path))
     (add-to-list 'exec-path "/usr/local/bin"))
   #+END_SRC

** Library Paths

Everything is situated underneath =user-emacs-directory (~/.emacs.d)=

This makes everything self-contained and easy to migrate to other
environments.

This section contains all of the path configurations that are not machine
specific. A seperate directory =(~/.emacs-meta)= is configured for =Meta=
information files (backups, temporary files, etc.)

*** Metafiles

First, we need to define the  =metafiles-dir= values.

#+BEGIN_SRC emacs-lisp
(defvar metafiles-dir
  "~/.emacs-meta" "Custom location for metadata.")
#+END_SRC

As this may be the first time I am running in this environment, the
=metafiles-dir= directory may not actually exist. We go ahead and create
it if it doesn't.

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p metafiles-dir)
  (make-directory metafiles-dir))
#+END_SRC

*** Temporary directory

I can now set the Emacs temporary directory to be within the
=metafiles-dir=, again creating it if necessary.

#+BEGIN_SRC emacs-lisp
(setq temporary-file-directory (concat metafiles-dir "/tmp/"))
(unless (file-exists-p temporary-file-directory)
  (make-directory temporary-file-directory))
#+END_SRC

** Package Management

I have moved /almost/ everything to use the package management system
instead of referencing external projects directly. This is extremely
convenient and makes updates very simple.

My Emacs packages are now managed by [[https://github.com/cask/cask][Cask]] and [[https://github.com/rdallasgray/pallet][Pallet]], along with =use-package=.

I maintain a list of the packages I am using here, but the actual list of
pacakges is managed in the =Cask= file. Pallet helps to ensure that the
packages installed are kept in sync with the dependency spec.

*** Packages

This list is a /mostly/ up-to-date list of the packages I use. Refer to the
=Cask= file for the list of packages actually installed.

My friend [[https://github.com/gordyt][Gordon]] put together the following script to generate a list of
the packages installed, which means the list is more up-to-date than it
used to be.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun jme/gen-package-table ()
    "Generate a table of all installed packages, along with their descriptions"
    (cons '("_Package Name_" "_Package Description_")
    (sort
     (mapcar
      (lambda (pkg-desc)
        (list (car pkg-desc) (package-desc-summary (cadr pkg-desc))))
      package-alist)
     `(lambda (a b) (string-lessp (car a) (car b))))))

  (jme/gen-package-table)
#+END_SRC

#+RESULTS:
| _Package Name_                  | _Package Description_                                                              |
| ace-jump-mode                   | a quick cursor location minor mode for emacs                                       |
| ace-window                      | Quickly switch windows.                                                            |
| alert                           | Growl-style notification system for Emacs                                          |
| annoying-arrows-mode            | Ring the bell if using arrows too much                                             |
| async                           | Asynchronous processing in Emacs                                                   |
| auctex                          | Integrated environment for *TeX*                                                   |
| auto-compile                    | automatically compile Emacs Lisp libraries                                         |
| auto-complete                   | Auto Completion for GNU Emacs                                                      |
| bbdb                            | The Insidious Big Brother Database for GNU Emacs                                   |
| bind-key                        | A simple way to manage personal keybindings                                        |
| cask                            | Cask: Project management for Emacs package development                             |
| cider                           | Clojure Integrated Development Environment and REPL                                |
| clojure-cheatsheet              | The Clojure Cheatsheet for Emacs                                                   |
| clojure-mode                    | Major mode for Clojure code                                                        |
| clojure-mode-extra-font-locking | Extra font-locking for Clojure mode                                                |
| clojure-snippets                | Yasnippets for clojure                                                             |
| cm-mode                         | Minor mode for CriticMarkup                                                        |
| cmake-mode                      | major-mode for editing CMake sources                                               |
| coffee-mode                     | Major mode to edit CoffeeScript files in Emacs                                     |
| color-theme-sanityinc-tomorrow  | A version of Chris Kempson's various Tomorrow themes                               |
| company                         | Modular text completion framework                                                  |
| concurrent                      | Concurrent utility functions for emacs lisp                                        |
| creole                          | A parser for the Creole Wiki language                                              |
| ctable                          | Table component for Emacs Lisp                                                     |
| dash                            | A modern list library for Emacs                                                    |
| db                              | A database for EmacsLisp                                                           |
| deferred                        | Simple asynchronous functions for emacs lisp                                       |
| deft                            | quickly browse, filter, and edit plain text notes                                  |
| diminish                        | Diminished modes are minor modes with no modeline display                          |
| dired+                          | Extensions to Dired.                                                               |
| direx                           | Simple Directory Explorer                                                          |
| edit-server                     | server that responds to edit requests from Chrome                                  |
| elnode                          | The Emacs webserver.                                                               |
| epc                             | A RPC stack for the Emacs Lisp                                                     |
| epl                             | Emacs Package Library                                                              |
| expand-region                   | Increase selected region by semantic units.                                        |
| f                               | Modern API for working with files and directories                                  |
| faceup                          | Regression test system for font-lock                                               |
| fakir                           | fakeing bits of Emacs                                                              |
| flx                             | fuzzy matching with good sorting                                                   |
| flx-ido                         | flx integration for ido                                                            |
| flycheck                        | Modern on-the-fly syntax checking for GNU Emacs                                    |
| flycheck-clojure                | Flycheck: Clojure support                                                          |
| flycheck-haskell                | Flycheck: Cabal projects and sandboxes                                             |
| flycheck-pos-tip                | Flycheck errors display in tooltip                                                 |
| fringe-helper                   | helper functions for fringe bitmaps                                                |
| ghci-completion                 | Completion for GHCi commands in inferior-haskell buffers                           |
| git-commit-mode                 | Major mode for editing git commit messages                                         |
| git-gutter                      | Port of Sublime Text plugin GitGutter                                              |
| git-gutter-fringe               | Fringe version of git-gutter.el                                                    |
| git-messenger                   | Pop up last commit information of current line                                     |
| git-rebase-mode                 | Major mode for editing git rebase files                                            |
| git-timemachine                 | Walk through git revisions of a file                                               |
| gntp                            | Growl Notification Protocol for Emacs                                              |
| gnuplot                         | drive gnuplot from within emacs                                                    |
| gnuplot-mode                    | Major mode for editing gnuplot scripts                                             |
| graphviz-dot-mode               | Mode for the dot-language used by graphviz (att).                                  |
| guide-key                       | Guide the following key bindings automatically and dynamically                     |
| handlebars-mode                 | A major mode for editing Handlebars files.                                         |
| haskell-mode                    | A Haskell editing mode                                                             |
| helm                            | Helm is an Emacs incremental and narrowing framework                               |
| helm-descbinds                  | Yet Another `describe-bindings' with `helm'.                                       |
| helm-git-files                  | helm for git files                                                                 |
| helm-projectile                 | Helm integration for Projectile                                                    |
| helm-swoop                      | Efficiently hopping squeezed lines powered by helm interface                       |
| hi2                             | indentation module for Haskell Mode                                                |
| highlight-indentation           | Minor modes for highlighting indentation                                           |
| htmlize                         | Convert buffer text and decorations to HTML.                                       |
| hydra                           | Make bindings that stick around                                                    |
| ido-ubiquitous                  | Use ido (nearly) everywhere.                                                       |
| ido-vertical-mode               | Makes ido-mode display vertically.                                                 |
| jabber                          | A Jabber client for Emacs.                                                         |
| jedi                            | a Python auto-completion for Emacs                                                 |
| jedi-core                       | Common code of jedi.el and company-jedi.el                                         |
| js2-mode                        | Improved JavaScript editing mode                                                   |
| kv                              | key/value data structure functions                                                 |
| let-alist                       | Easily let-bind values of an assoc-list by their names                             |
| log4e                           | provide logging framework for elisp                                                |
| magit                           | control Git from Emacs                                                             |
| markdown-mode                   | Emacs Major mode for Markdown-formatted text files                                 |
| markdown-mode+                  | extra functions for markdown-mode                                                  |
| multi-term                      | Managing multiple terminal buffers in Emacs.                                       |
| noflet                          | locally override functions                                                         |
| nose                            | Easy Python test running in Emacs                                                  |
| org                             | Outline-based notes management and organizer                                       |
| org-bullets                     | Show bullets in org-mode as UTF-8 characters                                       |
| org-mac-iCal                    | Imports events from iCal.app to the Emacs diary                                    |
| ox-reveal                       | reveal.js Presentation Back-End for Org Export Engine                              |
| package-build                   | Tools for assembling a package archive                                             |
| packed                          | package manager agnostic Emacs Lisp package utilities                              |
| pallet                          | A package management tool for Emacs, using Cask.                                   |
| paradox                         | A modern Packages Menu. Colored, with package ratings, and customizable.           |
| pkg-info                        | Information about packages                                                         |
| plantuml-mode                   | Major mode for plantuml                                                            |
| popup                           | Visual Popup User Interface                                                        |
| popwin                          | Popup Window Manager.                                                              |
| pretty-mode                     | Redisplay parts of the buffer as pretty symbols.                                   |
| projectile                      | Manage and navigate projects in Emacs easily                                       |
| pydoc-info                      | Better Python support for info-lookup-symbol.                                      |
| python-environment              | virtualenv API for Emacs Lisp                                                      |
| queue                           | Queue data structure                                                               |
| racket-mode                     | Major mode for Racket language.                                                    |
| rainbow-delimiters              | Highlight brackets according to their depth                                        |
| rainbow-mode                    | Colorize color names in buffers                                                    |
| request                         | Compatible layer for URL request in Emacs                                          |
| request-deferred                | Wrap request.el by deferred                                                        |
| restclient                      | An interactive HTTP client for Emacs                                               |
| s                               | The long lost Emacs string manipulation library.                                   |
| scala-mode2                     | Major mode for editing Scala >= 2.9                                                |
| shut-up                         | Shut up would you!                                                                 |
| slamhound                       | Rip Clojure namespaces apart and rebuild them.                                     |
| slime                           | Superior Lisp Interaction Mode for Emacs                                           |
| smartparens                     | Automatic insertion, wrapping and paredit-like navigation with user defined pairs. |
| smex                            | M-x interface with Ido-style fuzzy matching.                                       |
| spinner                         | Add spinners and progress-bars to the mode-line for ongoing operations             |
| stylus-mode                     | Major mode for editing .jade files                                                 |
| sws-mode                        | (S)ignificant (W)hite(S)pace mode                                                  |
| test-simple                     | Simple Unit Test Framework for Emacs Lisp                                          |
| undo-tree                       | Treat undo history as a tree                                                       |
| use-package                     | A use-package declaration for simplifying your .emacs                              |
| web                             | useful HTTP client                                                                 |
| window-layout                   | window layout manager                                                              |
| xml-rpc                         | An elisp implementation of clientside XML-RPC                                      |
| yasnippet                       | Yet another snippet extension for Emacs.                                           |

** Additional Paths

I add the =user-emacs-directory= to the load path here to ensure we can pick up
the additional configuration files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat user-emacs-directory "/lisp"))
#+END_SRC

I also add all top-level subdirectories of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp
(let ((default-directory user-emacs-directory))
      (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

*** Paths for meta-information

I set up variables for all paths needed for storing things in the
=meta-information= directory. By consolidating them all in one place (and
using the variables later), I have an easier time keeping track of them
and maintaining them.

| Variable         | Purpose                                                                                                   |
|------------------+-----------------------------------------------------------------------------------------------------------|
| =meta-saveplace= | Name of the file that records the =save-place-alist=, which stores the location of point in visited files |
| =meta-backup=    | Location for backup files                                                                                 |
| =meta-bookmarks= | Bookmarks file.                                                                                           |
| =meta-savehist=  | File used by =savehist= where minibuffer history is saved to and loaded                                   |
| =meta-recent=    | File to save the recent list into                                                                         |
| =meta-saves=     | Prefix to use for auto-save files                                                                         |
| =meta-ido=       | File in which the =ido= state is saved between invocations                                                |
| =meta-tramp=     | File used for =tramp= persistence                                                                         |

#+BEGIN_SRC emacs-lisp
(defvar meta-saveplace (concat metafiles-dir "/saveplace")
  "Name of the file that records save-place-alist.")
(defvar meta-bookmarks (concat metafiles-dir "/bookmarks")
  "Location for bookmarks file.")
(defvar meta-savehist (concat metafiles-dir "/savehist")
  "File used by savehist where minibuffer history is saved to and loaded.")
(defvar meta-recent (concat metafiles-dir "/recentf")
  "File to save the recent list into.")
(defvar meta-saves (concat metafiles-dir "/auto-save-list/.saves-")
  "Prefix to use for auto-save files.")
(defvar meta-ido (concat metafiles-dir "/ido.last")
  "File in which the ido state is saved between invocations.")
(defvar meta-tramp (concat metafiles-dir "/tramp")
  "File used for tramp persistence.")
(defvar meta-url (concat metafiles-dir "/url")
  "Directory for url files.")
#+END_SRC

*** Non-packaged packages

I used to use several packages that did not exist in package archives. In
order to handle loading these, I added the 3rd party libraries in the
=vendor= directory. I no longer do this, but have kept the logic for
reference, though it is no longer tangled to the generated file.

#+BEGIN_SRC emacs-lisp :tangle no
(defvar vendor-dir (concat user-emacs-directory "vendor")
  "3rd party library directory for items not managed by Cask.")
(unless (file-exists-p vendor-dir)
  (make-directory vendor-dir))
(add-to-list 'load-path vendor-dir)
(let ((default-directory vendor-dir))
     (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

Make sure we are not using stale files. The =auto-compile= package helps
ensure the latest version of source files are compiled.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package auto-compile
  :ensure t
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

I leverage the =bind-key= package to do all of my key-binding. I need
to =require= it in early to handle all of my mode-specific key
bindings. Not sure this is technically required to be loaded anymore since
it is a dependancy of =use-package=, but it doesn't hurt.

#+BEGIN_SRC emacs-lisp
(use-package bind-key
  :ensure t)
#+END_SRC

*** System and user specific configuration

I run the same configuration on several machines. Different machines have
different capabilities as well as different file system layouts. To handle
this situation, I load system specific files based on the name of the
machine. I also load in a file based on user name, to handle additional
environments.

My previous implementation for handling this had become too complicated and
had some trouble with ordering. So, I have simplified things by having
several functions.

**** Custom Settings

   Keep emacs Custom-settings in separate file. I previously converted most
   of my variable assignmets to setting custom variables during
   init. Therefore, the contents of the =custom.el= file is mostly
   populated from configuration.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

**** Basic loading function
#+BEGIN_SRC emacs-lisp
(defun jme/load (directory base)
  "Look for files located in DIRECTORY whose base name is BASE.

Check the base name against several extensions.  If a file with
that name exists, then load it."
  (let ((literate      (expand-file-name (concat base ".org") directory))
        (encrypted-org (expand-file-name (concat base ".org.gpg") directory))
        (plain         (expand-file-name (concat base ".el") directory))
        (encrypted-el  (expand-file-name (concat base ".el.gpg") directory)))
   (cond
    ((file-exists-p encrypted-org) (org-babel-load-file encrypted-org))
    ((file-exists-p encrypted-el)  (load encrypted-el))
    ((file-exists-p literate)      (org-babel-load-file literate))
    ((file-exists-p plain)         (load plain)))))
#+END_SRC

**** Private settings

     Personal information that should not be shared is kept in a private
     file.

#+BEGIN_SRC emacs-lisp
(jme/load user-emacs-directory ".private")
#+END_SRC

**** OS-specific settings

     Settings specific to machine type are kept in their own settings file.

#+BEGIN_SRC emacs-lisp
(let* ((system-name (symbol-name system-type))
       (base-name (replace-regexp-in-string "/" "-" system-name)))
  (jme/load user-emacs-directory base-name))
#+END_SRC

**** Hostname-specific settings

     Settings specific to a particular machine, identified by host name,
     are stored in their own settings file.

#+BEGIN_SRC emacs-lisp
(let ((host-name-base (car (split-string (system-name) "\\."))))
  (jme/load user-emacs-directory host-name-base))
#+END_SRC

**** User-specific settings

#+BEGIN_SRC emacs-lisp
(jme/load user-emacs-directory user-login-name)
#+END_SRC

**** Custom configuration

   Finally, we load any settings set by ~customize~.

#+BEGIN_SRC emacs-lisp
(load custom-file)
#+END_SRC

** General Emacs Settings

There are a number of configuration items I tend to look at as basic
configuration. There is a fine line between what is a /package/ and what
is just part of Emacs, especially at the rate things are being included in
the /official/ distribution.

*** Window sizing

When using a =window-system=, which I most often do, I like to start Emacs
with a specific window size and position. This code accomplishes that.

First, we need to set up the window sizing.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (defvar emacs-min-top)
  (defvar emacs-min-left)
  (defvar emacs-min-height)
  (defvar emacs-min-width))

(if window-system
    (unless noninteractive
      (defvar emacs-min-top 22)
      (defvar emacs-min-left 5)
      (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
      (defvar emacs-min-width 100)))
#+END_SRC

This function resets the window to its minimal position.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-min ()
"Reset frame size to minumum."
  (interactive)
  (set-frame-parameter (selected-frame) 'fullscreen nil)
  (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'top emacs-min-top)
  (set-frame-parameter (selected-frame) 'left emacs-min-left)
  (set-frame-parameter (selected-frame) 'height emacs-min-height)
  (set-frame-parameter (selected-frame) 'width emacs-min-width))
#+END_SRC

This function does the opposite of the above. It sets the window to
maximum position.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-max ()
"Reset frame size to maximum."
  (interactive)
  (if t
      (progn
        (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
    (set-frame-parameter (selected-frame) 'top 26)
    (set-frame-parameter (selected-frame) 'left 2)
    (set-frame-parameter (selected-frame) 'width
                         (floor (/ (float (x-display-pixel-width)) 9.15)))
    (if (= 1050 (x-display-pixel-height))
        (set-frame-parameter (selected-frame) 'height
                             (if (>= emacs-major-version 24)
                                 66
                               55))
      (set-frame-parameter (selected-frame) 'height
                           (if (>= emacs-major-version 24)
                               75
                             64)))))
#+END_SRC

One last function to give me the ability to toggle between the two.

#+BEGIN_SRC emacs-lisp
(defun jme/emacs-toggle-size ()
"Toggle between minimum and maximum size of frame."
  (interactive)
  (if (> (cdr (assq 'width (frame-parameters))) 100)
      (jme/emacs-min)
    (jme/emacs-max)))
#+END_SRC

I start off with Emacs in its minimal state when starting up. Since moving
to the =mac= Emacs port on my Apple machines, as opposed to the =ns=
version, I don't really use the toggle much anymore. Instead I use the mac
fullscreen mode.

#+BEGIN_SRC emacs-lisp
(if window-system
    (add-hook 'after-init-hook 'jme/emacs-min))
#+END_SRC

*** Coding system

I am a fan of UTF-8. Make sure everything is set up to handle it.

| Variable                     | Value   | Description          |
|------------------------------+---------+----------------------|
| =set-terminal-coding-system= | =utf-8= | terminal output      |
| =set-terminal-coding-system= | =utf-8= | terminal input       |
| =perfer-coding-system=       | =utf-8= | set preferred coding |

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Interface settings

I most often have the audio on my machines muted, so use the visible bell
instead of beeps. Who likes beeps anyway?

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

Make sure I can see what it is that I am typing. This setting is the
number of seconds to pause before unfinished commands are echoed. I find
the default of 1 second a bit slow.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC

I am not a big fan of overloading the arrow keys. Plus they are just too
far away from my fingers to be useful. Don't use the shift+arrows for mark.

#+BEGIN_SRC emacs-lisp
(setq shift-select-mode nil)
#+END_SRC

Use point instead of click with mouse yank.

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC

While I no longer have a machine with a mouse connected (only trackpads
now), I still use swipe-type scrolling which I would like to be smooth.

These settings handle one line at a time, disable scrolling acceleration
and scroll the window under the mouse.

#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
(setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ; scroll window under mouse
#+END_SRC

Truncate lines in windows narrower than the frame.

#+BEGIN_SRC emacs-lisp
(setq truncate-partial-width-windows t)
#+END_SRC

Set the default tab stop.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

Never put tabs in files, use spaces instead. If, for some reason, a real
tab is needed, use =C-q C-i= to insert one.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

I want to always go to the next indent level when hitting return.

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
#+END_SRC

Add newlines to the end of the file if I naviagate past it.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)
#+END_SRC

Set the column that triggers fill

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 75)
#+END_SRC

Turn on auto fill for text files.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC

Allow narrowing.

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-defun 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

*** Visual tweaks

Unlike a number of people, I do not mind the menu bar if I am actually
using a window system of some kind. It is not that I use it often, but it
does not get in my way much either. So, I check to see if I am using a
window system and disable it if not. Turns out that this is still annoying
when the window system does not support global menus as is the case when I
am running on my chromebook with i3wm. Still need a solution for that case.

#+BEGIN_SRC emacs-lisp
(if (eq window-system 'nil)
    (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode 1)))
#+END_SRC

The toolbar, however, is completely useless to me, so I always disable it.

#+BEGIN_SRC emacs-lisp
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

Likewise, scrollbars offer no value.

#+BEGIN_SRC emacs-lisp
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Visually indicate empty lines after the buffer end. This is shown as a
fringe bitmap in the left edge.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
#+END_SRC

Cause Emacs to fully redraw the display before it processes queued input
events. Apparently this provides a slight performance tweak for newer
machines. My machines seem to be able to handle it. Picked up from
[[http://www.masteringemacs.org/articles/2011/10/02/improving-performance-emacs-display-engine/][here]].

#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t)
#+END_SRC

**** Modeline

I refer to my modeline quite often. It is very easy for it to get too
cluttered, it is expensive real estate.

Show the line:column number.

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Also, show the size of the file.

#+BEGIN_SRC emacs-lisp
(size-indication-mode 1)
#+END_SRC

***** Battery information

Battery information display in the modeline is controlled by
=battery-mode-line-format= and =battery-status-function=. I enable this
whenever I am on a mac, +as I only have mac laptops+ (now running on a
chromebook also).

=battery-mode-line-format= is a customizable variable, I am setting it here
to reflect the following format:

  - "⚡︎ "
  - status
    - =empty= - high
    - =-= - low
    - =!= - critical
    - =+= - charging
  - load percentage
  - =%=
  - " " - a space
  - time remaining

The result should look something like:

=⚡︎ 42% 2:30=

#+BEGIN_SRC emacs-lisp :tangle no
  (if (string-equal system-type "darwin")
      (custom-set-variables
        '(battery-mode-line-format "⚡️%b%p%% %t "))
    (custom-set-variables
      '(battery-mode-line-format "⚡︎ %b%p%%%% %t ")))
  (display-battery-mode)
#+END_SRC

I have opted for a simpler and 'clearer' solution utilizing the
`fancy-battery` package.

#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
    (add-hook 'after-init-hook #'fancy-battery-mode))
#+END_SRC

***** Time

I often run emacs in a fullscreen fashion that does not display the system
clock on my desktop. However, I often refer to the clock, thus I add it to
the modeline. The =display-time= functionality in Emacs is quite robust and
can potentially display much more information than just the time. I
configure it here to my liking.

#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average nil)  ; Don't display load
  (setq display-time-day-and-date nil)  ; Don't display date
  (custom-set-variables
      '(display-time-format "%l:%M%p"))
  (display-time-mode)
#+END_SRC

*** Miscellaneous

Add newline to end of file on save.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Make Emacs use the clipboard

#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
#+END_SRC

Seed the random-number generator

#+BEGIN_SRC emacs-lisp
(random t)
#+END_SRC

Prefix used for generating the auto save file names.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix meta-saves)
#+END_SRC

Use "y" in place of "yes", who wants to type all of those extra characters?

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

**** Bookmarks

Save bookmarks into their own file in the meta information directory.

#+BEGIN_SRC emacs-lisp
(custom-set-variables '(bookmark-default-file meta-bookmarks))
#+END_SRC

**** Backup

I like all of my backup copies of files to be in a common location.

Configure where the backups should go.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (quote ((".*" . "~/.emacs-meta/backups/"))))
#+END_SRC

I like to use version numbers for the backup files. Set the number of
newest versions and oldest versions to keep when a new numbered backup is
made. I also don't care about the deletion of excess backup versions, so do
that silently. Also, I like to use copying to create backups for files
that are linked, instead of renaming.

| Variable                        | Value | Description                                                          |
|---------------------------------+-------+----------------------------------------------------------------------|
| =version-control=               | =t=   | Control use of version numbers for backup files                      |
| =kept-new-versions=             | =2=   | Number of newest versions to keep when a new numbered backup is made |
| =kept-old-versions=             | =2=   | Number of oldest versions to keep when a new numbered backup is made |
| =delete-old-versions=           | =t=   | When set to =t=, delete excess backup versions silently              |
| =backup-by-copying-when-linked= | =t=   | Use copying to create backups for files with multiple names          |

#+BEGIN_SRC emacs-lisp
(setq
  version-control t
  kept-new-versions 2
  kept-old-versions 2
  delete-old-versions t
  backup-by-copying-when-linked t)
#+END_SRC

**** URL Related

     Make sure to store URL related stuff in the right place.

     #+BEGIN_SRC emacs-lisp
     (setq url-cookie-file (concat meta-url "/cookies"))
     (setq url-cache-directory (concat temporary-file-directory "url/cache"))
     #+END_SRC

*** Global mode settings

**** Auto-revert

Revert buffers when they change on disk.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(diminish 'auto-revert-mode)
#+END_SRC

Auto-refresh dired buffers.

#+BEGIN_SRC emacs-lisp
(custom-set-variables '(global-auto-revert-non-file-buffers t))
#+END_SRC

But.. don't announce reversion of buffer

#+BEGIN_SRC emacs-lisp
(custom-set-variables '(auto-revert-verbose nil))
#+END_SRC

**** Git gutter

Git gutter is a nice little utility that adds markers in the fringe to
denote changes in a file. I like this everywhere, so I turn it on globally.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :diminish git-gutter-mode
  :config
  (progn
    (setq git-gutter:lighter " GG")
    (global-git-gutter-mode)))
#+END_SRC

**** Git messenger

#+BEGIN_SRC emacs-lisp
(use-package git-messenger
  :commands git-messenger:popup-message
  :ensure t
  :bind ("C-x v p" . git-messenger:popup-message))
#+END_SRC

**** Recentf

Save recently used files. This turns on the "Open Recent" submenu which is
displayed in the "File" menu, containing a list of files that were
operated on recently.

I use the following settings for this mode:

| variable                 | value         | description                       |
|--------------------------+---------------+-----------------------------------|
| =recentf-save-file=      | =meta-recent= | File to save the recent list into |
| =recent-max-saved-items= | 100           | Max number of items saved         |
| =recent-max-menu-items=  | 15            | Max number of items in menu       |

Since the loading of the recent file and cleanup can take some time, I
turn it on once things are idle.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (progn
    (setq
      recentf-save-file meta-recent
      recentf-max-saved-items 100
      recentf-max-menu-items 15)
    (recentf-mode t)))
#+END_SRC

**** Savehist

Save minibuffer history. The minibuffer history is saved periodically
(every 300 seconds, in this case) and when exiting Emacs. I use
=savehist-file= to specify the filename (in the meta information directory)
where the history should be stored. Additionally, I have it set to save:

| History type         | Description                                        |
|----------------------+----------------------------------------------------|
| =search-ring=        | List of search string sequences                    |
| =regexp-search-ring= | List of regular expression search string sequences |

#+BEGIN_SRC emacs-lisp
(use-package savehist
  :config
  (progn
    (setq savehist-additional-variables
      '(kill-ring search-ring regexp-search-ring)
      savehist-autosave-interval 300
      savehist-file meta-savehist
      history-delete-duplicates t)
    (savehist-mode t)))
#+END_SRC

**** Saveplace

Preserve the location of point in file when saving files.

I specify the name of the file that records saveplace information, so the
contents go into the =meta= area and activate it for all buffers.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
  (progn
    (setq save-place-file meta-saveplace)
    (setq-default save-place t)))
#+END_SRC

**** Show Paren mode

I like to visually see the matching parens. =Show Paren= mode is a global
minor mode that highlights matching parens. I have now replaced the
original =show paren= with =smartparens=.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :commands (smartparens-mode
             show-smartparens-mode
             show-smartparens-global-mode)
  :diminish smartparens-mode
  :ensure t
  :config
  (progn
         (use-package smartparens-config)
         ;(smartparens-global-mode) ;; commented out until bug? fixed
         (show-smartparens-global-mode)))
#+END_SRC

**** Undo-tree-mode

=Undo-tree-mode= replaces Emacs' standard undo feature with a more
powerful, yet easier to user version, that treats the undo history as what
it is: a tree.

Enable =Undo-tree-mode= globally.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t)))
#+END_SRC

**** Whitespace

I like to see whitespace in files. I find this helps with both
organization and formatting. I use the following style for whitespace
visualization:

| Style            | Description                           |
|------------------+---------------------------------------|
| face             | enable all visualization via faces    |
| trailing         | trailing blanks                       |
| space-before-tab | SPACEs before TAB                     |
| space-after-tab  | 8 or more SPACEs after a TAB          |
| indentation      | 8 or more SPACEs at beginning of line |

I also specify the column beyond which the line is highlighted.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :diminish global-whitespace-mode
  :config
  (progn
    (setq whitespace-style '(face trailing space-before-tab
                       indentation space-after-tab)
          whitespace-line-column 80)
    (global-whitespace-mode 1)))

#+END_SRC

**** Winner

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure t
  :if (not noninteractive)
  :demand t
  :config (winner-mode 1))
#+END_SRC

* Utility functions

There are a number of /utility/ functions that I keep around for handling
different things. Some of them are experimental, but they /do/ work.

** Hide or Expand

I have kept this around for a long time and go through different phases
of using it. I have recently gone back to using it quite a bit now that I
have been using =winner= mode.

#+BEGIN_SRC emacs-lisp
(defun hide-or-expand ()
  "Hide or expand a window."
  (interactive)
  (if (> (length (window-list)) 1)
      (delete-other-windows)
    (bury-buffer)))
#+END_SRC

* Package Specific Settings
** Avy

   Replacement for ace-jump-mode and other things.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-. C-s" . avy-goto-word-1))
#+END_SRC

** Aggressive Indent

   Avoid manual indentation with 'aggressive indent'.

   #+BEGIN_SRC emacs-lisp
   (use-package aggressive-indent
      :ensure t
      :diminish (aggressive-indent-mode . "➠")
      :config
        (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
   #+END_SRC

** Auto complete (Company)

I have fiddled around with different auto-completion packages and
extensions over time. This one works.

#+BEGIN_SRC emacs-lisp
(use-package company
   :ensure t
   :diminish company-mode
   :config
     (global-company-mode)
   :init
   (progn
     (setq company-tooltip-limit 20
           company-idle-delay .3)))
#+END_SRC

** Ace-isearch

   Neat little package that provides a minor mode which combines isearch,
   avy and helm-swoop. See setup for helm-swoop key bindings.

   #+BEGIN_SRC emacs-lisp
   (use-package ace-isearch
     :ensure t
     :diminish ace-isearch-mode
     :config
       (custom-set-variables
         '(ace-isearch-function 'avy-goto-word-1)
         '(ace-isearch-junp-delay 0.5)
         '(ace-isearch-input-length 5)))

   (global-ace-isearch-mode +1)
   #+END_SRC

** YASnippet

YASnippet is an excellent template system for Emacs and it works very well
with Auto Complete. I use it everywhere I can.

YASnippet does not provide a way to expand a snippet programmatically, so
we create one. (Based on code from [[http://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][this]] Stack Overflow question.)

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config (yas-global-mode 1))

  (defun jme/insert-yas-by-name (name)
    (cl-flet ((dummy-prompt
               (prompt choices &optional display-fn)
               (declare (ignore prompt))
               (or (find name choices :key display-fn :test #'string=)
                   (throw 'notfound nil))))
      (let ((yas/prompt-functions '(dummy-prompt)))
        (catch 'notfound
          (yas/insert-snippet t)))))
#+END_SRC

Here we provide an indication that there is a yasnippet available to be
used. (From [[https://github.com/pcmantz/elisp/blob/master/my-bindings.el][here]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-132][here]]).

#+BEGIN_SRC emacs-lisp
(defvar default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))
  "Capture the default cursor color so we can switch back to it if needed.")
(defvar yasnippet-can-fire-cursor-color "purple"
  "Color to change cursor when yasnippet is available.")

(defun jme/yasnippet-can-fire-p (&optional field)
  "Test if yasnippet can expand."
  (interactive)
  (setq yas--condition-cache-timestamp (current-time))
  (let (templates-and-pos)
    (unless (and yas-expand-only-for-last-commands
                 (not (member last-command yas-expand-only-for-last-commands)))
      (setq templates-and-pos (if field
                                  (save-restriction
                                    (narrow-to-region (yas--field-start field)
                                                      (yas--field-end field))
                                    (yas--templates-for-key-at-point))
                                (yas--templates-for-key-at-point))))
    (and templates-and-pos (first templates-and-pos))))

(defun jme/change-cursor-color-when-can-expand (&optional field)
  (interactive)
  (when (eq last-command 'self-insert-command)
    (set-cursor-color (if (jme/can-expand)
                          yasnippet-can-fire-cursor-color
                        default-cursor-color))))

(defun jme/can-expand ()
  "Return true if right after an expandable thing."
  (or (abbrev--before-point) (jme/yasnippet-can-fire-p)))

(add-hook 'post-command-hook 'jme/change-cursor-color-when-can-expand)
#+END_SRC

** Clojure

   Support for Clojure.

*** Clojure Mode

    #+BEGIN_SRC emacs-lisp
    (use-package clojure-mode
      :ensure t
      :init
      (progn
        (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
        (add-hook 'clojure-mode-hook #'smartparens-strict-mode)))
    #+END_SRC

*** Cider

    #+BEGIN_SRC emacs-lisp
    (use-package cider
      :ensure t
      :init
      (progn
        (add-hook 'cider-mode-hook #'eldoc-mode)
        (add-hook 'cider-mode-hook #'rainbow-delimiters-mode)
        (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
        (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)))
    #+END_SRC

*** Clojure Cheatsheet
    #+BEGIN_SRC emacs-lisp
    (use-package clojure-cheatsheet
      :ensure t)
    #+END_SRC

*** Clojure mode extra font locking
    #+BEGIN_SRC emacs-lisp
    (use-package clojure-mode-extra-font-locking
      :ensure t)
    #+END_SRC

*** Clojure snippets for Yasnippets
    #+BEGIN_SRC emacs-lisp
    (use-package clojure-snippets
      :ensure t)
    #+END_SRC

*** Flycheck for Clojure
    #+BEGIN_SRC emacs-lisp
    (use-package flycheck-clojure
      :ensure t)
    #+END_SRC

*** Slamhound
    #+BEGIN_SRC emacs-lisp
    (use-package slamhound
      :ensure t)
    #+END_SRC
** CoffeeScript

Support for CoffeeScript.

#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :commands coffee-mode
    :mode ("\\.coffee\\'" . coffee-custom)
    :init
    (setq
      coffee-js-mode 'js2-mode
      coffee-tab-width 2
      coffee-args-compile '("-c" "--bare") ;; If you don't want your compiled files to be wrapped
      coffee-debug-mode t)
    :config
    (bind-key "M-r" 'coffee-compile-buffer coffee-mode-map))
#+END_SRC

** Deft

I find Deft to be a great note-taking utility.

#+BEGIN_SRC emacs-lisp
(use-package deft
  :commands deft
  :ensure t
  :init
  (progn
    (setq
      deft-extension "org"
      deft-text-mode 'org-mode)
    (when (boundp 'my-notes)
      (setq deft-directory my-notes)))
  :bind ("<f9>" . deft))
#+END_SRC

** Dired

I have been trying to train myself to use =dired= as much as possible. My
go-to alternative is the command line, which often interrupts whatever I
was doing in the particular shell I choose. My settings here are still
very much experimental.

I moved to using =dired+= to pick up some extra features.

Make sure =image-dired= keeps its files in the meta directory.

#+BEGIN_SRC emacs-lisp
;; diredp-toggle-find-file-reuse-dir 1
  (use-package dired+
    :ensure t
    :config
    (progn
      (setq image-dired-dir (concat metafiles-dir "/image-dired"))
      (put 'dired-find-alternate-file 'disabled nil)  ;enable `a' command
      (diredp-toggle-find-file-reuse-dir 1)))

#+END_SRC

** Erlang

#+BEGIN_SRC emacs-lisp
(use-package erlang-start
  :disabled t)
#+END_SRC

** Expand Region

A fantastically useful package to gradually expand selected region.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :commands er/expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish flycheck-mode
    :init
    (setq-default flycheck-disabled-checkers
      (append flycheck-disabled-checkers
        '(javascript-jshint)))
    :config
    (progn
      (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
      (flycheck-clojure-setup)
      (global-flycheck-mode)
      (flycheck-add-mode 'javascript-eslint 'web-mode)
      (flycheck-add-mode 'html-tidy 'web-mode)
      (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck)))
#+END_SRC

   #+BEGIN_SRC emacs-lisp
   (use-package flycheck-pos-tip
     :ensure t)
   #+END_SRC

** Flyspell

I often use =flyspell= mode when writing text documents. I typically turn
this on a some point after I have already begun writing. This bit of
advice ensures that the buffer is checked when I turn =flyspell= on.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  (defadvice flyspell-mode (after advice-flyspell-check-buffer-on-start activate)
    (flyspell-buffer)))
#+END_SRC

** Guide Key

Nice utility for providing a guide for key bindings.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :diminish guide-key-mode
  :ensure t
  :config
  (progn
    (setq guide-key/guide-key-sequence '("C-x" "C-c"))
    (guide-key-mode 1)
    (setq guide-key/recursive-key-sequence-flag t)
    (setq guide-key/popup-window-position 'bottom)))
#+END_SRC

** Haskell

Make sure to ignore compiled Haskell files in filename completions.  Since
I like automatic indentation, it needs to be turned on for Haskell.  Also,
make sure to show documentation.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :commands haskell-mode
  :mode ("\\.l?hs\\'" . haskell-mode)
  :init
    (add-to-list 'completion-ignored-extensions ".hi")
  :config
  (progn
    (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
    (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)))
#+END_SRC

** Ido

Provide an easy way to load a recent file utilizing ido.

#+BEGIN_SRC emacs-lisp
  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
        (find-file file))))
#+END_SRC

Configure ido to use vertical mode. Much easier to see matches.

#+BEGIN_SRC emacs-lisp
(use-package ido-vertical-mode
  :ensure t
  :config (ido-vertical-mode))
#+END_SRC

Use ido everywhere.

#+BEGIN_SRC emacs-lisp
(use-package ido-ubiquitous
  :disabled t
  :ensure t
  :init
  (eval-after-load "ido" (ido-ubiquitous-mode 1)))
#+END_SRC

*** Configuration

These settings control the behavior of ido.

| Setting                              | Value      | Description                                        |
|--------------------------------------+------------+----------------------------------------------------|
| =ido-case-fold=                      | =t=        | Ignore case when searching                         |
| =ido-confirm-unique-completion=      | =t=        | wait for RET, even with unique completion          |
| =ido-create-new-buffer=              | =always=   | Always create new buffers unconditionally          |
| =ido-enable-flex-matching=           | =t=        | Use flexible string matching                       |
| =ido-enable-last-directory-history=  | =t=        | Remember latest selected directory name            |
| =ido-max-prospects=                  | =10=       | Limit prospect list to 10 values                   |
| =ido-max-work-directory-list=        | =30=       | Maximum number of working directories to record    |
| =ido-max-work-file-list=             | =50=       | Maximum number of names of recently opened files   |
| =ido-save-directory-list-file=       | =meta-ido= | File used to store ido state                       |
| =ido-use-filename-at-point=          | =nil=      | Don't attempt to use filename at point as starting point |
| =ido-use-url-at-point=               | =nil=      | Don't attempt to use URL at point                  |
| =confirm-nonexistent-file-or-buffer= | =nil=      | Don't confirm before visiting a non-existent file  |

#+BEGIN_SRC emacs-lisp
(use-package flx-ido
  :ensure t
  :config
  (progn
    (ido-mode t)
    (setq
     ido-case-fold  t                 ; be case-insensitive
     ido-confirm-unique-completion t  ; wait for RET, even with unique completion
     ido-create-new-buffer 'always
;     ido-enable-flex-matching t
     ido-enable-last-directory-history t ; remember last used dirs
     ido-max-prospects 10
     ido-max-work-directory-list 30   ; should be enough
     ido-max-work-file-list      50   ; remember many
     ido-save-directory-list-file meta-ido
     ido-use-filename-at-point nil
     ido-use-url-at-point nil
     ido-everywhere 1
     flx-ido-mode 1)
;; increase minibuffer size when ido completion is active
    (add-hook 'ido-minibuffer-setup-hook
      (function
        (lambda ()
          (set (make-local-variable 'resize-minibuffer-window-max-height) 1))))))

(setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

** Helm

   Helm helps with completion of many things. I am finding it easier to
   work with than other modules.

#+BEGIN_SRC emacs-lisp
(defvar jme/helm-sources '(helm-source-buffers-list
                           helm-source-recentf
                           helm-source-bookmarks
                           helm-source-file-cache
                           helm-source-files-in-current-dir))
(use-package helm
  :commands (helm-M-x
             helm-apropos
             helm-do-grep
             helm-occur
             helm-find-files
             helm-for-files
             helm-all-mark-rings
             helm-man-woman
             helm-mini
             helm-register
             helm-semantic-or-imenu
             helm-show-kill-ring)
  :ensure t
  :diminish helm-mode
  :config
  (progn
    (require 'helm-config)
    (setq helm-for-files-preferred-list jme/helm-sources
          helm-split-window-in-side-p t
          helm-scoll-amount 8)
    (helm-mode 1)
    (helm-autoresize-mode 1))
  :bind (("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("M-x" . helm-M-x)
         ("M-y" . helm-show-kill-ring)
         ("C-c h g" . helm-google-suggest)
         ("C-c h o" . helm-occur)
         ("C-c h x" . helm-register)
         ("C-c h SPC" . helm-all-mark-rings)
         ("C-h a" . helm-apropos)
         ("M-s a" . helm-do-grep)
         ("M-s f" . helm-for-files)))
#+END_SRC

Helm can do a great job of describing bindings.

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :commands (helm-descbinds)
  :bind ("C-h b" . helm-descbinds))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :commands (helm-swoop helm-swoop-back-to-last-point)
    :ensure t
    :bind (("C-c h s" . helm-swoop)
           ("M-i" . helm-swoop)
           ("M-I" . helm-swoop-back-to-last-point))
    :config
    (progn
      (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
      (bind-key "M-i" 'helm-multi-swoop-all-from-helm-swoop helm-swoop-map)
      (bind-key "C-s" 'helm-next-line helm-swoop-map)
      (bind-key "C-r" 'helm-previous-line helm-swoop-map)))
#+END_SRC

*** Flycheck

    Add helm support for flycheck.

    #+BEGIN_SRC emacs-lisp
    (use-package helm-flycheck
      :ensure t)
    #+END_SRC

** Javascript
   Make sure to handle json files appropriately.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :commands json-mode
    :mode ("\\.json$" . json-mode)
    :init
    (setq-default json-reformat::indent-width 2
                  js-indent-level 2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :commands js2-mode
  :mode ("\\.js$" . js2-mode)
  :init
  (progn
    (setq-default js2-basic-offset 2)
    (add-to-list 'interpreter-mode-alist (cons "node" 'js2-mode)))
  :config
  (progn
    (bind-key "C-x C-e" 'js-send-last-sexp js2-mode-map)
    (bind-key "C-M-x" 'js-send-last-sexp-and-go js2-mode-map)
    (bind-key "C-c b" 'js-send-buffer js2-mode-map)
    (bind-key "C-c C-b" 'js-send-buffer-and-go js2-mode-map)
    (bind-key "C-c w" 'my/copy-javascript-region-or-buffer js2-mode-map)
    (bind-key "C-c l" 'js-load-file-and-go js2-mode-map)))
#+END_SRC

If we have the ability to use javascript in an inferior process, use Node
for that.

#+BEGIN_SRC emacs-lisp
(use-package js-comint
  :disabled t
  :init
  (custom-set-variables '(inferior-js-program-command "node")))
#+END_SRC

** LaTeX

Configure AUCTeX to automatically save style information when saving the
buffer and to parse the file after loading to get style information.

Also, query for the name of the master file.

#+BEGIN_SRC emacs-lisp
(use-package tex-site
  :mode ("\\.tex\\'" . TeX-latex-mode)
  :init
  (progn
    (setq
      TeX-auto-save t
      TeX-parse-self t)
    (setq-default TeX-master nil)))
#+END_SRC

** Lisp

   Eldoc provides minibuffer hints when working with Emacs lisp.
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :diminish eldoc-mode
  :commands eldoc-mode
  :init
  (progn
    (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)))

(bind-key "C-c ." 'find-function-at-point emacs-lisp-mode-map)
(bind-key "C-c f" 'find-function emacs-lisp-mode-map)
(bind-key "M-:" 'pp-eval-expression)

(add-hook 'lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
(add-hook 'emacs-lisp-mode-hook (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands magit-status
  :ensure t
  :bind ("C-x d" . magit-status)
  :init (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode
  (("\\.markdown$" . markdown-mode)
   ("\\.md$" . markdown-mode)))
#+END_SRC

** Newsticker

#+BEGIN_SRC emacs-lisp
(use-package newsticker
  :commands (newsticker-show-news newsticker-start)
  :init
  (progn
    (setq
      newsticker-cache-filename (concat metafiles-dir "/.newsticker-cache")
      newsticker-dir (concat metafiles-dir "/newsticker/")))
  :config
  (setq-default
   newsticker-automatically-mark-items-as-old nil
   newsticker-automatically-mark-visited-items-as-old t
   newsticker-obsolete-item-max-age (* 30 (* 24 3600))
   newsticker-hide-immortal-items-in-echo-area t
   newsticker-hide-obsolete-items-in-echo-area t
   newsticker-date-format "(%A, %B %d %I:%M%p)"))
#+END_SRC

** Org

My =org= mode settings are contained in their own file. This function
loads the configuration based on my login name.

#+BEGIN_SRC emacs-lisp
(jme/load user-emacs-directory (concat user-login-name "-org"))
#+END_SRC

** Pianobar

#+BEGIN_SRC emacs-lisp
(use-package pianobar
  :disabled t)
#+END_SRC

** Projectile
   Projectile works as a nice, light-weight, project management tool.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :config
  (progn
    (use-package helm-projectile
      :ensure t
      :config
      (progn
        (setq projectile-completion-system 'helm
              projectile-switch-project-action 'helm-projectile)
        (helm-projectile-on)))
    (setq projectile-keymap-prefix (kbd "C-c p")
          projectile-enable-caching t)
    (projectile-global-mode)))

#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
(setq python-remove-cwd-from-path nil)

; Bring back indent after newline
(add-hook 'python-mode-hook '(lambda ()
             (define-key python-mode-map "\C-m" 'newline-and-indent)))

#+END_SRC

   Use python3

   #+BEGIN_SRC emacs-lisp
   (setq python-shell-interpreter "python3"
         python-shell-interpreter-args "-i")
   #+END_SRC

 use ipython (no more)

#+BEGIN_SRC emacs-lisp :tangle no
(setq python-shell-interpreter "ipython"
       python-shell-interpreter-args "-i -v")
#+END_SRC

 Jedi for Python
#+BEGIN_SRC emacs-lisp
(use-package jedi
 :commands jedi:setup
  :disabled t
  :init
  (progn
    (setq jedi:setup-keys t)
    (add-hook 'python-mode-hook 'jedi:setup)))
#+END_SRC

  Highlight indentation

  #+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
   :ensure t
   :commands highlight-indent-guides-mode
   :init
   (progn
    (setq highlight-indent-guides-method 'character)
    (add-hook 'python-mode-hook 'highlight-indent-guides-mode)))
  #+END_SRC
** Rainbow mode

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode
  :init
  (add-hook 'css-mode-hook 'rainbow-mode))
#+END_SRC

** Shell

I try to use my shell within Emacs as much as possible. I will admit that
I have not yet been able to do this completely, though the desire is
there.

#+BEGIN_SRC emacs-lisp
(use-package comint
  :init
  (progn
    (bind-key "M-p" 'comint-previous-matching-input-from-input comint-mode-map)
    (bind-key "M-n" 'comint-next-matching-input-from-input comint-mode-map)
    (bind-key "C-M-n" 'comint-next-input comint-mode-map)
    (bind-key "C-M-p" 'comint-previous-input comint-mode-map)
    (setq comint-prompt-read-only t)
    (add-hook 'term-exec-hook
          (function
           (lambda ()
             (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))))
#+END_SRC

Ensure that the shell prompt is read only, not doing this is just weird.

#+BEGIN_SRC emacs-lisp

#+END_SRC

Update the mode's keybindings to work to my liking.

Ensure the shell is set to UTF-8.

#+BEGIN_SRC emacs-lisp

#+END_SRC

Autoload =multi-term= and =multi-term-next= so they can be used in key
bindings.

#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :commands (multi-term multi-term-next)
  :bind (("C-c t" . multi-term-next)
         ("C-c T" . multi-term)))
#+END_SRC

Tramp is a fantastic package that allows for remote file editing. Make sure
tramp uses ssh by default. Also make sure that files are stored in the meta
information directory.

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :init
  (setq
    tramp-default-method "ssh"
    tramp-persistency-file-name meta-tramp))
#+END_SRC

I provide a regexp to match my prompts.

#+BEGIN_SRC emacs-lisp
(setq shell-prompt-pattern "^[^a-zA-Z].*[#$%>☞] *")
#+END_SRC

** Smex

#+BEGIN_SRC emacs-lisp
(use-package smex
  :commands (smex smex-major-mode-commands execute-extended-command)
  :init
  (setq smex-save-file (concat metafiles-dir "/.smex-items"))
  :config
  (smex-initialize)
  :bind (("M-X" . smex-major-mode-commands)
         ("C-c C-c M-x" . execute-extended-command)))
#+END_SRC

** Swank-js

#+BEGIN_SRC emacs-lisp
(use-package slime-js
  :commands (slime-js-minor-mode slime-js-refresh-css slime-js-embed-css)
  :init
  (progn
    (add-hook 'js2-mode-hook
              (lambda ()
                (slime-js-minor-mode 1)))
    (add-hook 'css-mode-hook
              (lambda ()
                (bind-key "M-C-x" 'slime-js-refresh-css css-mode-map)
                (bind-key "C-c C-r" 'slime-js-embed-css css-mode-map)))))
#+END_SRC

** Uniquify

By default, Emacs makes buffer names unique by adding =<2>=, =<3>=,
etc. to the end of the buffer name. I don't find this particularly
useful. Using the =Uniquify= package, I can easily change this behavior.

Use the =post-forward= type of naming for buffers. This names the buffer
with the file name followed by a shortened form of the path.

For example:

=/foo/bar/mumble/name= becomes =name|bar/mumble=

I change the string used as a separator for the buffer name components to
be ":".

Also, make sure to rerationalize buffer names after a buffer has been killed.

Some buffers should not be uniquified. I also provide a regular expression here
for these exceptions.


#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :init
  (setq
    uniquify-buffer-name-style 'post-forward
    uniquify-separator ":"
    uniquify-after-kill-buffer-p t
    uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

** Web mode

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode
    (("\\.jsx$" . web-mode)
     ("\\.html?\\'" . web-mode))
    :init
    (progn
      (setq web-mode-markup-indent-offset 2
            web-mode-css-indent-offset 2
            web-mode-code-indent-offset 2
            web-mode-enable-current-column-highlight t))
    :config
    (progn
      (defadvice web-mode-highlight-part (around tweak-jsx activate)
        (if (equal web-mode-content-type "jsx")
            (let ((web-mode-enable-part-face nil))
              ad-do-it)
          ad-do-it))
      (add-hook 'web-mode-hook
        (lambda ()
          (when (equal web-mode-content-type "jsx")
            (flycheck-select-checker 'javascript-eslint)
            (flycheck-select-checker 'flycheck-tidyrc))))))
#+END_SRC

** Diminish

I use diminish to hide most of minor modes from the modeline. Most of the
diminish functionality has been updated into the =use-package= calls.

#+BEGIN_SRC emacs-lisp
(eval-after-load "highlight-indentation" '(diminish 'highlight-indentation-mode))
(diminish 'overwrite-mode "💀")
#+END_SRC

* Custom Configuration

** Window handling

*** Rotating Windows

I often have my frame split into multiple windows. I find it very handy to
swap buffers between windows if I am working in multiple buffers at the
same time. I came across this function to rotate buffers through windows
(you can find it [[http://whattheemacsd.com/buffer-defuns.el-02.html][here]].)

#+BEGIN_SRC emacs-lisp
  (defun jme/rotate-windows ()
    "Rotate your windows."
    (interactive)
    (cond ((not (> (count-windows)1))
           (message "You can't rotate a single window!"))
          (t
           (let ((i 1)
                 (numWindows (count-windows)))
           (while  (< i numWindows)
             (let* (
                    (w1 (elt (window-list) i))
                    (w2 (elt (window-list) (+ (% i numWindows) 1)))
                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))
                    (s1 (window-start w1))
                    (s2 (window-start w2))
                    )
               (set-window-buffer w1  b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i (1+ i))))))))
#+END_SRC

*** Window Split

This function toggles between horizontal and vertical layout of two
windows. (Picked up from [[http://whattheemacsd.com/buffer-defuns.el-03.html][here]].)

#+BEGIN_SRC emacs-lisp
(defun jme/toggle-window-split ()
 "Toggle between horizontal and vertical layout of windows."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

*** More window splitting

I really like the idea of the following functions (covered by Sacha [[https://www.youtube.com/watch?v%3DnKCKuRuvAOw&feature%3Dyoutu.be][here]],
original source [[http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][here]]). I don't override the normal split keybindings since
I very often want several windows with the same buffer.

#+BEGIN_SRC emacs-lisp
(defun jme/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1)
    (switch-to-next-buffer)))
(defun jme/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))
#+END_SRC

*** Window switching
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :init (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :bind ("C-x o" . ace-window))
#+END_SRC

** Cleanup

Whitespace cleanup can be dangerous if it changes the content of the
file. Some changes are guaranteed to be safe, which this function sticks
to, allowing it to be safe for a =before-save-hook=. (see
[[http://whattheemacsd.com/buffer-defuns.el-01.html][this article]].)

#+BEGIN_SRC emacs-lisp
(defun jme/cleanup-buffer-safe ()
  "Perform a bunch of safe operations on the whitespace content of a buffer.
Does not indent buffer, because it is used for a `before-save-hook', and that
might be bad."
  (interactive)
  (untabify (point-min) (point-max))
  (delete-trailing-whitespace)
  (set-buffer-file-coding-system 'utf-8))
#+END_SRC

If we want to be less careful when cleaning up, we can do that too.

#+BEGIN_SRC emacs-lisp
(defun jme/cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (jme/cleanup-buffer-safe)
  (indent-region (point-min) (point-max)))
#+END_SRC

Make sure we hook this into our save process.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'jme/cleanup-buffer-safe)
#+END_SRC

** Movement

*** Better handling of move to beginning of line

I find it useful to move to the beginning of the indentation as opposed to
strickly the beginning of the line. This accomplishes that in a smart
way. (See
[[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][this article]].)

#+BEGIN_SRC emacs-lisp
  (defun jme/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'jme/smarter-move-beginning-of-line)
#+END_SRC

** Mark

Mark handling when ~transient-mark-mode~ can be a little confusing when you
want to set the mark but not engage /tmm/. ~Mastering Emacs~ has a good
[[http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/][article]] on the subject.

#+BEGIN_SRC emacs-lisp
(defun jme/push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region.
Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jme/jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jme/exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(define-key global-map [remap exchange-point-and-mark] 'jme/exchange-point-and-mark-no-activate)
#+END_SRC

* Theme Configuration

** Custom Themes

I tend to like playing around with different color themes. Sometimes this
is based on mood, sometimes it is based on environment. These themes go
into their own directory.

#+BEGIN_SRC emacs-lisp
  (setq custom-theme-directory (concat user-emacs-directory "themes"))
#+END_SRC

** Fonts
I have moved to using the =Adobe Source Code Pro= font. More information
may be found on Source Code Pro can be found [[http://blog.typekit.com/2012/09/24/source-code-pro/][here]].

Two separate fonts are possible, one for normal use and the other for use
in presentation mode. Define some variables to hold them.

#+BEGIN_SRC emacs-lisp
  (defvar jme/default-font ""
    "Default font to use.")
  (defvar jme/presentation-font ""
    "Font to use for presentations.")
#+END_SRC

Set appropriate fonts for the platform.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (setq jme/default-font "-*-Source Code Pro-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
    (if (string-equal system-type "darwin")
        (setq jme/presentation-font "-*-Source Code Pro-normal-normal-normal-*-18-*-*-*-m-0-iso10646-1")
        (setq jme/presentation-font "-bitstream-bitstream vera sans mono-medium-r-*-*-*-120-*-*-*-*-*-*"))
      (set-face-attribute 'default nil :font jme/default-font))
#+END_SRC

** Load custom theme

*** Org source blocks

Color source blocks in org to make them stand out. See [[http://www.howardism.org/Technical/LP/dot-emacs.html][Howard Abrams Emacs Config]].

#+BEGIN_SRC emacs-lisp
(defun jme/org-src-color-blocks-light ()
  "Colors the block headers and footers to make them stand out more for lighter themes."
  (interactive)
  (custom-set-faces
   '(org-block-begin-line
    ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
   '(org-block-background
     ((t (:background "#FFFFEA"))))
   '(org-block-end-line
     ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))))

(defun jme/org-src-color-blocks-dark ()
  "Colors the block headers and footers to make them stand out more for dark themes."
  (interactive)
  (custom-set-faces
   '(org-block-begin-line
     ((t (:foreground "#008ED1" :background "#002E41"))))
   '(org-block-background
     ((t (:background "#111111"))))
   '(org-block-end-line
     ((t (:foreground "#008ED1" :background "#002E41"))))))
#+END_SRC

*** Presentation and Default theme

Under certain situations, changing the theme is desirable, specifically
when projecting on a larger screen. The following provides functions for
switching themes. I have updated this to use the sanityinc versions of
Chris Kempson's tommorow themes.

Need to make sure to capture the default cursor color so we can switch it
when appropriate.

#+BEGIN_SRC emacs-lisp
  (use-package material-theme
    :ensure t)

  (defun use-presentation-theme ()
   "Switch to presentation theme."
    (interactive)
    (load-theme 'material-light t)
    (when (boundp 'jme/presentation-font)
      (set-frame-font jme/presentation-font :frames nil)
      (set-face-attribute 'default nil :font jme/presentation-font))
    (setq default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))))

  (defun use-default-theme ()
   "Switch to the default theme."
    (interactive)
    (load-theme 'material t)
    (when (boundp 'jme/default-font)
      (set-frame-font jme/default-font :frames nil)
      (set-face-attribute 'default nil :font jme/default-font))
    (setq default-cursor-color (cdr (assoc 'cursor-color (frame-parameters)))))

  (defun toggle-presentation-mode ()
   "Toggle between presentation and default theme."
    (interactive)
    (if (string= (frame-parameter nil 'font) jme/default-font)
        (use-presentation-theme)
      (use-default-theme)))

  (use-default-theme)
#+END_SRC

hide-mode-line provides a way for me to hide the mode line during
presentations.

#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line)
#+END_SRC

For presentations themselves, provide org-present.

#+BEGIN_SRC emacs-lisp
(use-package org-present
  :config (add-hook 'org-present-mode-hook
                    (lambda ()
                       (org-display-inline-images)
                       (hide-mode-line)
                       (use-presentation-theme)))
          (add-hook 'org-present-mode-quit-hook
                    (lambda ()
                       (org-remove-inline-images)
                       (use-default-theme)
                       (hide-mode-line))))
#+END_SRC

** Monkey Mode Line

My own invention of a mode line layout.

#+BEGIN_SRC emacs-lisp
  ;(use-package monkey-mode-line
  ;  :config (monkeyml/monkey-mode-line))
  (use-package spaceline
    :ensure t
    :config
    (use-package spaceline-config
      :config
      (use-package monkey-spaceline
        :load-path "lisp/"
        :config (spaceline-monkey-theme))))
#+END_SRC

* Key Bindings

I have debated several times about where to locate key bindings. While
there is a good argument to keeping them near the functions/configuration
they relate to, I find it better to have all global keys in one place.

| Key        | Action                      | Comments                            |
|------------+-----------------------------+-------------------------------------|
| =C-z=      | hide-or-expand              | Thought of as analog to shell sleep |
| =M-`=      | jme/push-mark-no-activate   |                                     |
| =C-`=      | pop-to-mark-command         |                                     |
| =C-==      | expand-region               |                                     |
| =C-c h=    | helm-mini                   |                                     |
| =C-c n=    | jme/cleanup-buffer          | Destructive cleanup of buffer       |
| =C-c on=   | jme/todays-daypage          | Open daypage for current day        |
| =C-c oN=   | jme/jme/find-daypage        | Open a specific day page            |
| =C-c t=    | multi-term-next             | Reuse terminal                      |
| =C-c T=    | multi-term                  | Create a new terminal               |
| =C-c v p=  | git-messenger:popup-message | Popup the last git commit message   |
| =C-x <up>= | jme/rotate-windows          | Rotates windows                     |
| =C-. C-s=  | ace-jump-mode               |                                     |
| =C-<f9>=   | toggle-presentation-mode    | switch in/out presentation theme    |

** Top-level mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'hide-or-expand)

(bind-key "M-`" 'jme/push-mark-no-activate)
(bind-key "C-`" 'pop-to-mark-command)

#+END_SRC

** =C-c= mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-c n" 'jme/cleanup-buffer)
(bind-key "C-c on" 'jme/todays-daypage)
(bind-key "C-c oN" 'jme/find-daypage)
#+END_SRC

** =C-x= mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-x <up>" 'jme/rotate-windows)
#+END_SRC

** Function Key mappings

#+BEGIN_SRC emacs-lisp
(bind-key "C-<f9>" 'toggle-presentation-mode)
#+END_SRC

* Emacs Server

#+BEGIN_SRC emacs-lisp
;; Don't start the server unless we can verify that it isn't running.
(use-package server
  :if (and window-system
           (not noninteractive))
  :config
  (when (and (functionp 'server-running-p) (not (server-running-p)))
     (server-start)))

;; Support for Chrome 'edit with emacs' extension
(use-package edit-server
  :if (and window-system
           (not noninteractive))
  :config
  (edit-server-start t))
#+END_SRC

* Footer

Add in the expected Emacs module footer.

#+BEGIN_SRC emacs-lisp
(provide 'init-ext)
;;; init-ext.el ends here
#+END_SRC
