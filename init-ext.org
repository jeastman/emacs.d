#+TITLE: Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything

* Reworking Configuration

  Emacs configuration is an endless effort for me. Several years ago,
  I converted my configuration over to an org-based literate style. It
  was a major undertaking, but I believe it has paid of. While my
  configuration continued to change and grow, it did so in an orderly
  and well documented manner. Yet, here I am again, nearly re-writing
  my entire configuration. Even the best maintained systems deserve a
  refresh every now and then. While not everything is new, experience
  has convinced me that there are some better ways to do things.

* File Header

  Add some comments to the beginning of the generated elisp file.

  #+BEGIN_SRC emacs-lisp :padline no
  ;;; init-ext.el -- Automatically generated initialization file
  ;;;
  ;;; This file is generated based on the init-ext.org file.
  ;;; Please refer to that file for complete documentation.
  ;;;
  ;;; Commentary:
  ;;; See init-ext.org
  ;;;
  ;;; Code:
  ;;;
  #+END_SRC

* Early loading

  These items need to be setup as early as possible in the Emacs loading process.

** Auto compilation

   While using =load-prefer-newer= will prevent outdated byte code
   file from being loaded, there is still a possibility that a source
   file would not be recomipled. =auto-compile= works to fill this
   gap.

   Ensure we are always using the latest code. =auto-compile= ensures
   that source files are recompiled if newer than their compiled form.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-compile
       :demand t
       :ensure t
       :config
       (progn
         (auto-compile-on-load-mode)
         (auto-compile-on-save-mode)))
   #+END_SRC

** Variable definitions

   Some variables require being defined early on due to their use in
   other modules.

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar jme:helm-sources '(helm-source-buffers-list
                                helm-source-recentf
                                helm-source-bookmarks
                                helm-source-file-cache
                                helm-source-files-in-current-dir))
   #+END_SRC


* General configuration
** Exec path

   Pull the exec path from our shell, this ensures all of the binaries
   we expect are available to us.

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :if (memq window-system '(mac ns))
       :ensure t
       :config
       (progn
         (when (string-match-p "/zsh$" (getenv "SHELL"))
           ;; Use a non-interactive login shell to ensure
           ;; zsh path is loaded properly from .zprofile
           ;; which only loads with a login shell.
           (setq exec-path-from-shell-arguments '("-l")))
         (exec-path-from-shell-initialize)))
   #+END_SRC

** Library paths

   Everything is situated underneath =user-emacs-directory (~/.emacs.d)=.

   This make everything self-contained and easy to migrate to other
   environments.

   This section contains all of the path configuration that are not
   machine specific. A seperate directory =(~/.emacs-meta)= is
   configured for =Meta= information (backups, temp files, etc.)

*** Metafiles

    First, we need to define the =metafiles-dir= values.

    #+BEGIN_SRC emacs-lisp
      (defvar metafiles-dir
        "~/.emacs-meta" "Custom location for metadata.")
    #+END_SRC

    As this may be the first time Emacs is running in this
    environment, the =metafiles-dir= directory may not actually
    exist. Go ahead and create it, if it does not.

    #+BEGIN_SRC emacs-lisp
      (unless (file-exists-p metafiles-dir)
        (make-directory metafiles-dir))
    #+END_SRC

*** Temporary directory

    Set the temporary directory to be inside the =metafiles-dir=.

    #+BEGIN_SRC emacs-lisp
      (setq temporary-file-directory (concat metafiles-dir "/tmp/"))
      (unless (file-exists-p temporary-file-directory)
        (make-directory temporary-file-directory))
    #+END_SRC

** Additional paths

   Add the =user-emacs-directory= to the load path to ensure we can
   pick up the additional configuration files.

   #+BEGIN_SRC emacs-lisp
        (add-to-list 'load-path (concat user-emacs-directory "/lisp"))
   #+END_SRC

*** Paths for meta-information

    Variables for all paths needed for storing things in the
    =metafiles-dir= directory. By consolidating them all in one place
    (and using the variables later), keeping track of them and
    maintaining them becomes easier. Later, =no-littering= will be
    used to catch all of the items we miss.

    | Variable         | Purpose                                                                                                   |
    |------------------+-----------------------------------------------------------------------------------------------------------|
    | =meta-config=    | Location of no-littering's etc directory                                                                  |
    | =meta-data=      | Location of no-littering's var directory                                                                  |
    | =meta-saveplace= | Name of the file that records the =save-place-alist=, which stores the location of point in visited files |
    | =meta-backup=    | Location for backup files                                                                                 |
    | =meta-bookmarks= | Bookmarks file.                                                                                           |
    | =meta-savehist=  | File used by =savehist= where minibuffer history is saved to and loaded                                   |
    | =meta-recent=    | File to save the recent list into                                                                         |
    | =meta-saves=     | Prefix to use for auto-save files                                                                         |
    | =meta-ido=       | File in which the =ido= state is saved between invocations                                                |
    | =meta-tramp=     | File used for =tramp= persistence                                                                         |

     #+BEGIN_SRC emacs-lisp
      (defvar meta-config (concat metafiles-dir "/etc/")
        "Location of etc directory for no-littering.")
      (defvar meta-data (concat metafiles-dir "/var/")
        "Location of var directory for no-littering.")
      (defvar meta-saveplace (concat metafiles-dir "/places")
        "Name of the file that records save-place-alist.")
      (defvar meta-bookmarks (concat metafiles-dir "/bookmarks")
        "Location for bookmarks file.")
      (defvar meta-savehist (concat metafiles-dir "/savehist")
        "File used by savehist where minibuffer history is saved to and loaded.")
      (defvar meta-recent (concat metafiles-dir "/recentf")
        "File to save the recent list into.")
      (defvar meta-saves (concat metafiles-dir "/auto-save-list/.saves-")
        "Prefix to use for auto-save files.")
      (defvar meta-ido (concat metafiles-dir "/ido.last")
        "File in which the ido state is saved between invocations.")
      (defvar meta-tramp (concat metafiles-dir "/tramp")
        "File used for tramp persistence.")
      (defvar meta-url (concat metafiles-dir "/url")
        "Directory for url files.")
    #+END_SRC

    Use =no-littering= package to keep things clean.

    #+BEGIN_SRC emacs-lisp
      (use-package no-littering
        :ensure t
        :demand t
        :init
        (setq no-littering-etc-directory meta-config
              no-littering-var-directory meta-data))
    #+END_SRC

*** Custom settings

    Keep emacs custom settings in a separate file. This helps to keep
    things clean in the configuration files. Most of the variable
    assignments in this configuration use the =custom-set-variables=
    function to set variables. This ensures that any special handling
    by packages is executed along with setting the variable.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(custom-file (expand-file-name "custom.el" user-emacs-directory)))
    #+END_SRC

** General Settings
*** Window sizing

    When using a =window-system=, which I most often do, I like to start
    Emacs with a specific window size and position. This code accomplishes
    that.

    First, we need to set up the window sizing.

    #+BEGIN_SRC emacs-lisp
      (eval-when-compile
        (defvar emacs-min-top)
        (defvar emacs-min-left)
        (defvar emacs-min-height)
        (defvar emacs-min-width))

      (if window-system
          (unless noninteractive
            (defvar emacs-min-top 22)
            (defvar emacs-min-left 5)
            (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
            (defvar emacs-min-width 100)))
    #+END_SRC

    This function resets the window to its minimal position.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-min ()
      "Reset frame size to minumum."
        (interactive)
        (set-frame-parameter (selected-frame) 'fullscreen nil)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'top emacs-min-top)
        (set-frame-parameter (selected-frame) 'left emacs-min-left)
        (set-frame-parameter (selected-frame) 'height emacs-min-height)
        (set-frame-parameter (selected-frame) 'width emacs-min-width))
    #+END_SRC

    This function does the opposite of the above. It sets the window to
    maximum position.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-max ()
      "Reset frame size to maximum."
        (interactive)
        (if t
            (progn
              (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
              (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
              (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
          (set-frame-parameter (selected-frame) 'top 26)
          (set-frame-parameter (selected-frame) 'left 2)
          (set-frame-parameter (selected-frame) 'width
                               (floor (/ (float (x-display-pixel-width)) 9.15)))
          (if (= 1050 (x-display-pixel-height))
              (set-frame-parameter (selected-frame) 'height
                                   (if (>= emacs-major-version 24)
                                       66
                                     55))
            (set-frame-parameter (selected-frame) 'height
                                 (if (>= emacs-major-version 24)
                                     75
                                   64)))))
    #+END_SRC

    One last function to give me the ability to toggle between the two.

    #+BEGIN_SRC emacs-lisp
      (defun jme:emacs-toggle-size ()
      "Toggle between minimum and maximum size of frame."
        (interactive)
        (if (> (cdr (assq 'width (frame-parameters))) 100)
            (jme:emacs-min)
          (jme:emacs-max)))
    #+END_SRC

    I start off with Emacs in its minimal state when starting up.

    #+BEGIN_SRC emacs-lisp
      (if window-system
          (add-hook 'after-init-hook 'jme:emacs-min))
    #+END_SRC

*** Coding system

    I am a fan of UTF-8. Make sure everything is set up to handle it.

    | Variable                     | Value   | Description          |
    |------------------------------+---------+----------------------|
    | =set-terminal-coding-system= | =utf-8= | terminal output      |
    | =set-terminal-coding-system= | =utf-8= | terminal input       |
    | =perfer-coding-system=       | =utf-8= | set preferred coding |

    #+BEGIN_SRC emacs-lisp
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
      (when (display-graphic-p)
        (custom-set-variables '(x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))))
    #+END_SRC

*** Interface settings

    I most often have the audio on my machines muted, so use the visible bell
    instead of beeps. Who likes beeps anyway?

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(visible-bell t))
    #+END_SRC

    Make sure I can see what it is that I am typing. This setting is the
    number of seconds to pause before unfinished commands are echoed. I
    find the default of 1 second a bit slow.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(echo-keystrokes 0.1))
    #+END_SRC

    I am not a big fan of overloading the arrow keys. Plus they are just too
    far away from my fingers to be useful. Don't use the shift+arrows for mark.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(shift-select-mode nil))
    #+END_SRC

    Use point instead of click with mouse yank.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(mouse-yank-at-point t))
    #+END_SRC

    While I no longer have a machine with a mouse connected (only trackpads
    now), I still use swipe-type scrolling which I would like to be smooth.

    These settings handle one line at a time, disable scrolling
    acceleration and scroll the window under the mouse.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(scroll-step 1)
                            '(mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
                            '(mouse-wheel-progressive-speed nil)            ; don't accelerate scrolling
                            '(mouse-wheel-follow-mouse 't))                 ; scroll window under mouse
    #+END_SRC

    Truncate lines in windows narrower than the frame. Providing an integer
    here specifies to truncate lines in each window narrower thant the full
    frame width, provided the total window width in column units is less
    than that integer; otherwise respect the value of =truncate-lines=.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(truncate-partial-width-windows 50))
    #+END_SRC

    Set the default tab stop.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(tab-width 4))
    #+END_SRC

    Never put tabs in files, use spaces instead. If, for some reason, a real
    tab is needed, use =C-q C-i= to insert one.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(indent-tabs-mode nil))
    #+END_SRC

    I want to always go to the next indent level when hitting return.

    #+BEGIN_SRC emacs-lisp
      (bind-key "RET" 'newline-and-indent)
    #+END_SRC

    Add newlines to the end of the file if I naviagate past it.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(next-line-add-newlines t))
    #+END_SRC

    Set the column that triggers fill

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(fill-column 75))
    #+END_SRC

    Turn on auto fill for text files.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
    #+END_SRC

    Allow narrowing.

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-defun 'disabled nil)
      (put 'narrow-to-page 'disabled nil)
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

*** Visual tweaks

    Unlike a number of people, I do not mind the menu bar if I am actually
    using a window system of some kind. It is not that I use it often, but
    it does not get in my way much either. So, I check to see if I am using
    a window system and disable it if not. Turns out that this is still
    annoying when the window system does not support global menus as is the
    case when I am running on my chromebook with i3wm. Still need a
    solution for that case.

    #+BEGIN_SRC emacs-lisp
      (if (eq window-system 'nil)
          (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode 1)))
    #+END_SRC

    The toolbar, however, is completely useless to me, so I always disable it.

    #+BEGIN_SRC emacs-lisp
      (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    #+END_SRC

    Likewise, scrollbars offer no value.

    #+BEGIN_SRC emacs-lisp
      (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    #+END_SRC

    Don't show the startup message.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(inhibit-startup-message t)
                            '(inhibit-startup-echo-area-message (user-login-name)))
    #+END_SRC

    Visually indicate empty lines after the buffer end. This is shown as a
    fringe bitmap in the left edge.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(indicate-empty-lines t))
    #+END_SRC

**** Icon support

     #+BEGIN_SRC emacs-lisp
       (use-package all-the-icons
        :ensure t)
     #+END_SRC

**** Modeline

     I refer to my modeline quite often. It is very easy for it to get too
     cluttered, it is expensive real estate.

     Show the line:column number.

     #+BEGIN_SRC emacs-lisp
       (line-number-mode 1)
       (column-number-mode 1)
     #+END_SRC

     Also, show the size of the file.

     #+BEGIN_SRC emacs-lisp
       (size-indication-mode 1)
     #+END_SRC

*** Miscellaneous

    Add newline to end of file on save.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(require-final-newline t))
    #+END_SRC

    Make Emacs use the clipboard

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(select-enable-clipboard t))
    #+END_SRC

    Prefix used for generating the auto save file names.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables '(auto-save-list-file-prefix meta-saves))
    #+END_SRC

    Use "y" in place of "yes", who wants to type all of those extra characters?

    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

**** Bookmarks

     Save bookmarks into their own file in the meta information directory.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(bookmark-default-file meta-bookmarks))
     #+END_SRC

**** Backup

     I like all of my backup copies of files to be in a common location.

     Configure where the backups should go.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(backup-directory-alist (quote ((".*" . "~/.emacs-meta/backups/")))))
     #+END_SRC

     I like to use version numbers for the backup files. Set the number of
     newest versions and oldest versions to keep when a new numbered backup
     is made. I also don't care about the deletion of excess backup
     versions, so do that silently. Also, I like to use copying to create
     backups for files that are linked, instead of renaming.

     | Variable                        | Value | Description                                                          |
     |---------------------------------+-------+----------------------------------------------------------------------|
     | =version-control=               | =t=   | Control use of version numbers for backup files                      |
     | =kept-new-versions=             | =2=   | Number of newest versions to keep when a new numbered backup is made |
     | =kept-old-versions=             | =2=   | Number of oldest versions to keep when a new numbered backup is made |
     | =delete-old-versions=           | =t=   | When set to =t=, delete excess backup versions silently              |
     | =backup-by-copying-when-linked= | =t=   | Use copying to create backups for files with multiple names          |

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables
         '(version-control t)
         '(kept-new-versions 2)
         '(kept-old-versions 2)
         '(delete-old-versions t)
         '(backup-by-copying-when-linked t))
     #+END_SRC

**** URL Related

     Make sure to store URL related stuff in the right place.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(url-cookie-file (concat meta-url "/cookies"))
                             '(url-cache-directory (concat temporary-file-directory "url/cache")))
     #+END_SRC

*** Global mode settings

**** Auto-revert

     Revert buffers when they change on disk.

     #+BEGIN_SRC emacs-lisp
       (global-auto-revert-mode 1)
     #+END_SRC

     Auto-refresh dired buffers.

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(global-auto-revert-non-file-buffers t))
     #+END_SRC

     But.. don't announce reversion of buffer

     #+BEGIN_SRC emacs-lisp
       (custom-set-variables '(auto-revert-verbose nil))
     #+END_SRC

**** Recentf

     Save recently used files. This turns on the "Open Recent" submenu
     which is displayed in the "File" menu, containing a list of files that
     were operated on recently.

     I use the following settings for this mode:

     | variable                 |         value | description                       |
     |--------------------------+---------------+-----------------------------------|
     | =recentf-save-file=      | =meta-recent= | File to save the recent list into |
     | =recent-max-saved-items= |           100 | Max number of items saved         |
     | =recent-max-menu-items=  |            15 | Max number of items in menu       |

     Since the loading of the recent file and cleanup can take some time, I
     turn it on once things are idle.

     #+BEGIN_SRC emacs-lisp
       (use-package recentf
         :custom
         (recentf-save-file meta-recent "Set the save file to be in meta area.")
         (recentf-max-saved-items 100 "Save 100 recent items.")
         (recentf-max-menu-items 15 "Maximum number of items in the recentf menu.")
         :config
           (recentf-mode t))
     #+END_SRC

**** Savehist

     Save minibuffer history. The minibuffer history is saved periodically
     (every 300 seconds, in this case) and when exiting Emacs. I use
     =savehist-file= to specify the filename (in the meta information
     directory) where the history should be stored. Additionally, I have it
     set to save:

     | History type         | Description                                        |
     |----------------------+----------------------------------------------------|
     | =search-ring=        | List of search string sequences                    |
     | =regexp-search-ring= | List of regular expression search string sequences |

     #+BEGIN_SRC emacs-lisp
       (use-package savehist
         :custom
         (savehist-additional-variables
          '(kill-ring search-ring regexp-search-ring))
         (savehist-autosave-interval 300)
         (savehist-file meta-savehist)
         (history-delete-duplicates t)
         :config
         (savehist-mode t))
     #+END_SRC

**** Saveplace

     Preserve the location of point in file when saving files.

     I specify the name of the file that records saveplace information, so
     the contents go into the =meta= area and activate it for all buffers.

     #+BEGIN_SRC emacs-lisp
       (use-package saveplace
         :init
         (progn
           (custom-set-variables '(save-place-file meta-saveplace))
           (save-place-mode t)))
     #+END_SRC

**** Whitespace

     I like to see whitespace in files. I find this helps with both
     organization and formatting. I use the following style for whitespace
     visualization:

     | Style            | Description                           |
     |------------------+---------------------------------------|
     | face             | enable all visualization via faces    |
     | trailing         | trailing blanks                       |
     | space-before-tab | SPACEs before TAB                     |
     | space-after-tab  | 8 or more SPACEs after a TAB          |
     | indentation      | 8 or more SPACEs at beginning of line |

     I also specify the column beyond which the line is highlighted.

     #+BEGIN_SRC emacs-lisp
       (use-package whitespace
         :diminish global-whitespace-mode
         :custom
         (whitespace-style '(face trailing space-before-tab
                                  indentation space-after-tab))
         (whitespace-line-column 80)
         :config
         (global-whitespace-mode 1))
     #+END_SRC

**** Uniquify

     By default, Emacs makes buffer names unique by adding =<2>=, =<3>=,
     etc. to the end of the buffer name. I don't find this particularly
     useful. Using the =Uniquify= package, I can easily change this behavior.

     Use the =post-forward= type of naming for buffers. This names the buffer
     with the file name followed by a shortened form of the path.

     For example:

     =/foo/bar/mumble/name= becomes =name|bar/mumble=

     I change the string used as a separator for the buffer name components
     to be ":".

     Also, make sure to rerationalize buffer names after a buffer has been
     killed.

     Some buffers should not be uniquified. I also provide a regular
     expression here for these exceptions.

     #+BEGIN_SRC emacs-lisp
       (use-package uniquify
         :custom
         (uniquify-buffer-name-style 'post-forward)
         (uniquify-separator ":")
         (uniquify-after-kill-buffer-p t)
         (uniquify-ignore-buffers-re "^\\*"))
     #+END_SRC

**** Cleanup

     Whitespace cleanup can be dangerous if it changes the content of the
     file. Some changes are guaranteed to be safe, which this function sticks
     to, allowing it to be safe for a =before-save-hook=. (see [[http://whattheemacsd.com/buffer-defuns.el-01.html][this article]].)

     #+BEGIN_SRC emacs-lisp
       (defun jme:cleanup-buffer-safe ()
         "Perform a bunch of safe operations on the whitespace content of a buffer.
       Does not indent buffer, because it is used for a `before-save-hook', and that
       might be bad."
         (interactive)
         (untabify (point-min) (point-max))
         (delete-trailing-whitespace)
         (set-buffer-file-coding-system 'utf-8))
     #+END_SRC

     If we want to be less careful when cleaning up, we can do that too.

     #+BEGIN_SRC emacs-lisp
       (defun jme:cleanup-buffer ()
         "Perform a bunch of operations on the whitespace content of a buffer.
       Including indent-buffer, which should not be called automatically on save."
         (interactive)
         (jme:cleanup-buffer-safe)
         (indent-region (point-min) (point-max)))
     #+END_SRC

     Make sure we hook this into our save process.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'before-save-hook 'jme:cleanup-buffer-safe)
     #+END_SRC


* Functionality Tweaks
** Auto complete (Company)

   I have fiddled around with different auto-completion packages and
   extensions over time. This one works.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :defer 2
       :diminish company-mode
       :custom
       (company-idle-delay .3)
       (company-minimum-prefix-length 2)
       (company-show-numbers t)
       (company-tooltip-align-annotations 't)
       :config
       (global-company-mode))
   #+END_SRC

   Statistical recent completions.

   #+BEGIN_SRC emacs-lisp
     (use-package company-statistics
       :ensure t
       :after (company)
       :config
       (company-statistics-mode))
   #+END_SRC

   Also enable fuzzy matching.

   #+BEGIN_SRC emacs-lisp
     (use-package company-flx
       :ensure t
       :after company
       :config
       (company-flx-mode +1))
   #+END_SRC

** Diminish

   I use diminish to hide most of minor modes from the modeline. Most of
   the diminish functionality has been updated into the =use-package=
   calls.

   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :ensure t
       :config
       (progn
         (eval-after-load "highlight-indentation" '(diminish 'highlight-indentation-mode))
         (diminish 'auto-revert-mode)
         (diminish 'auto-fill-function)
         (diminish 'overwrite-mode "💀")))
   #+END_SRC

** Dired
      I have been trying to train myself to use =dired= as much as
   possible. My go-to alternative is the command line, which often
   interrupts whatever I was doing in the particular shell I choose. My
   settings here are still very much experimental.

   #+BEGIN_SRC emacs-lisp
     (defun jme:dired-mode-setup ()
       "Setup for dired mode."
       (dired-hide-details-mode t))

     (use-package dired
       :commands dired
       :hook (dired-mode . jme:dired-mode-setup))
   #+END_SRC

   All-the-icons support in dired buffers. Becasue, who doesn't like icons?

   #+BEGIN_SRC emacs-lisp
   (use-package all-the-icons-dired
    :ensure t
    :after all-the-icons
    :commands all-the-icons-dired-mode
    :hook (dired-mode . all-the-icons-dired-mode))
   #+END_SRC

   Subtree support.

   #+BEGIN_SRC emacs-lisp
     (use-package dired-subtree
       :ensure t
       :commands (dired-subtree-insert dired-subtree remove)
       :after dired
       :bind (:map dired-mode-map
                   ("i" . dired-subtree-insert)
                   (";" . dired-subtree-remove)))
   #+END_SRC

   Filter support.

   #+BEGIN_SRC emacs-lisp
     (use-package dired-filter
       :ensure t
       :after dired
       :custom
       (dired-filter-group-saved-groups '(("default"
                                           ("Archives"
                                            (extension "zip" "rar" "gz" "bz2" "tar"))
                                           ("Data"
                                            (extension "json" "xml" "dat" "csv"))
                                           ("Documents"
                                            (extension "org" "markdown" "md" "adoc" "txt"))
                                           ("Binary"
                                            (extension "elc" "pyc"))
                                           ("Backup"
                                            (extension "el~" "backup"))
                                           ("Language"
                                            (extension "el" "py" "java" "sh" "awk" "rb"))
                                           ("LaTeX"
                                            (extension "tex" "bib"))
                                           ("Mac"
                                            (extension . "DS_Store"))
                                           ("PDF"
                                            (extension . "pdf"))
                                           ("Version Control"
                                            (extension "git" "gitignore" "gitconfig" "gitmodules"))
                                           ))))
   #+END_SRC


** Expand Region


   A fantastically useful package to gradually expand selected region.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :commands er/expand-region
       :bind ("C-=" . er/expand-region))
   #+END_SRC

** Helpful

   #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :ensure t
       :bind (("C-h f" . helpful-callable)
              ("C-h v" . helpful-variable)
              ("C-h k" . helpful-key)))
   #+END_SRC
** Paradox


   Better package management.

   #+BEGIN_SRC emacs-lisp
     (use-package paradox
       :ensure t
       :commands paradox-list-packages)
   #+END_SRC

** Rainbow Delimiters

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :ensure t
       :defer 1
       :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

** Smartparens

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :ensure t
       :defer 1
       :diminish
       :config
       (smartparens-global-mode 1))
   #+END_SRC

** Window switching

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :commands ace-window
       :bind ("C-x o" . ace-window)
       :config (custom-set-variables '(aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))))
   #+END_SRC


** Which Key

   I used to use [[https://github.com/kai2nenobu/guide-key][guide-key]] for remembering key combinations, but have now
   switched to [[https://github.com/justbur/emacs-which-key][which-key]] which appears to be nicer.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :defer 10
       :diminish which-key-mode
       :config
       (setq which-key-key-replacement-alist
             '(("left" . "◀")
               ("right" . "▶")
               ("up" . "▲")
               ("down" . "▼")))
       (which-key-mode 1))
   #+END_SRC

** Yasnippet

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :defer 1
       :diminish yas-minor-mode
       :config (yas-global-mode))

     (use-package yasnippet-snippets
       :ensure t
       :after yasnippet
       :config (yasnippet-snippets-initialize))
   #+END_SRC

* Functional Package Configuration

** AsciiDoc

   #+BEGIN_SRC emacs-lisp
     (use-package adoc-mode
       :ensure t)
   #+END_SRC

** Flycheck

    #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :diminish flycheck-mode
       :custom
       (flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
       :config
       (global-flycheck-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-pos-tip
       :ensure t)
   #+END_SRC

** Dashboard

   #+BEGIN_SRC emacs-lisp
          (defun jme:dashboard-banner ()
            """Set a dashboard banner including information on package initialization
             time and garbage collections."""
            (setq dashboard-banner-logo-title
                  (format "Emacs ready in %.2f seconds with %d garbage collections."
                          (float-time (time-subtract after-init-time before-init-time)) gcs-done)))

          (use-package dashboard
            :ensure t
            :hook ((dashboard-mode . jme:dashboard-banner)
                   (after-init . dashboard-refresh-buffer))
            :config
            (setq dashboard-startup-banner 'logo)
            (setq dashboard-items '((agenda . 5)
                                    (recents . 5)
                                    (projects . 5)
                                    (bookmarks . 5)
                                    (registers . 5)))
            (dashboard-setup-startup-hook))
   #+END_SRC

** Helm

   Helm helps with completion of many things. I am finding it easier to
   work with than other modules.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm
       :ensure t
       :diminish helm-mode
       :config
       (progn
         (require 'helm-config)
         (custom-set-variables '(helm-for-files-preferred-list jme:helm-sources)
                               '(helm-split-window-in-side-p t)
                               '(helm-scoll-amount 8))
         (helm-mode 1)
         (helm-autoresize-mode 1))
       :bind (("C-x b" . helm-mini)
              ("C-x C-b" . helm-buffers-list)
              ("C-x C-f" . helm-find-files)
              ("M-x" . helm-M-x)
              ("M-y" . helm-show-kill-ring)
              ("C-c h g" . helm-google-suggest)
              ("C-c h o" . helm-occur)
              ("C-c h x" . helm-register)
              ("C-c h SPC" . helm-all-mark-rings)
              ("C-h a" . helm-apropos)
              ("M-s a" . helm-do-grep)
              ("M-s f" . helm-for-files)))
   #+END_SRC

   Helm can do a great job of describing bindings.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm-descbinds
       :ensure t
       :commands (helm-descbinds)
       :bind ("C-h b" . helm-descbinds))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm-swoop
       :commands (helm-swoop helm-swoop-back-to-last-point)
       :ensure t
       :bind (("C-c h s" . helm-swoop)
              ("M-i" . helm-swoop)
              ("M-I" . helm-swoop-back-to-last-point)
              :map isearch-mode-map
              ("M-i" . helm-swoop-from-isearch)
              :map helm-swoop-map
              ("M-i" . helm-multi-swoop-all-from-helm-swoop)
              ("C-s" . helm-next-line)
              ("C-r" . helm-previous-line)))
   #+END_SRC

** Magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands magit-status
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package magit-gitflow
       :ensure t
       :hook (magit-mode . turn-on-magit-gitflow))
   #+END_SRC

** ile


   Projectile works as a nice, light-weight, project management tool.

   #+BEGIN_SRC emacs-lisp
          (use-package projectile
            :ensure t
            :diminish projectile-mode
            :custom
            (projectile-cache-file (concat metafiles-dir "/projectile.cache"))
            (projectile-known-projects-file (concat metafiles-dir "/projectile-bookmarks.eld"))
            (projectile-keymap-prefix (kbd "C-c p"))
            (projectile-enable-caching t)
            (projectile-completion-system 'ivy)
            :config
            (projectile-mode))
   #+END_SRC

   Support for org tasks associated with projectile projects.

   #+BEGIN_SRC emacs-lisp
;     (use-package org-projectile
;       :ensure t
;       :bind (("C-c n p" . org-projectile-project-todo-completing-read)
;              ("C-c c" . org-capture))
;       :config
;       (progn
;         (setq org-projectile-projects-file
;               (concat metafiles-dir "projects.org"))
;         (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
;         (push (org-projectile-project-todo-entry) org-capture-templates)))
   #+END_SRC

   Projectile Helm support.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm-projectile
       :ensure t
       :after projectile
       :config
       (progn
         (custom-set-variables '(projectile-completion-system 'helm)
                               '(projectile-switch-project-action 'helm-projectile))
         (helm-projectile-on)))

;     (use-package org-projectile-helm
;       :after org-projectile
;       :bind (("C-c n p" . org-projectile-helm-template-or-project)))
   #+END_SRC

** Ivy Support

   This is my attempt to switch from using Helm to Ivy.

   Add in counsel.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :ensure t
       :after ivy
       :config (counsel-mode))
   #+END_SRC

   Ivy package

   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :ensure t
       :defer 0.1
       :diminish
       :bind (("C-c C-r" . ivy-resume)
              ("C-x B" . ivy-switch-buffer-other-window))
       :custom
       (ivy-count-format "(%d/%d) ")
       (ivy-display-style 'fancy)
       (ivy-use-virtual-buffers t)
       :config (ivy-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-hydra
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-rich
       :ensure t
       :after ivy
       :custom
       (ivy-virtual-abbreviate 'full
                               ivy-rich-switch-buffer-align-virtual-buffer t
                               ivy-rich-path-style 'abbrev)
       :config
       (ivy-set-display-transformer 'ivy-switch-buffer
                                    'ivy-rich-switch-buffer-transformer)
       (ivy-rich-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-ivy
       :ensure t
       :config
       (all-the-icons-ivy-setup))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :ensure t
       :after ivy
       :bind (("C-s" . swiper)
              ("C-r" . swiper)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :ensure t
       :after (ivy projectile)
       :config
       (counsel-projectile-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-yasnippet
       :ensure t
       :after (ivy yasnippet))
   #+END_SRC

* Lanugage Support
** JavaScript

   Support for editing JSON files.

   #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :ensure t
        :commands json-mode
        :mode ("\\.json$" . json-mode))
   #+END_SRC

   General JavaScript support using j2s-mode.

   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :ensure t
       :commands js2-mode
       :mode ("\\.js$" . js2-mode)
       :bind (:map js2-mode-map
                   ("C-x C-e" . js-send-last-sexp)
                   ("C-M-x" . js-send-last-sexp-and-go)
                   ("C-c b" . js-send-buffer)
                   ("C-c l" . js-load-file-and-go))
       :init
       (progn
         (setq js-indent-level 2)
         (setq js-strict-missing-semi-warning nil)
         (add-to-list 'interpreter-mode-alist (cons "node" 'js2-mode))))
   #+END_SRC

   Support for editing React JSX files.

   #+BEGIN_SRC emacs-lisp
     (use-package rjsx-mode
       :ensure t
       :after js2-mode)
   #+END_SRC


* Custom Settings

  Load any local customizations. Note that by doing this at the end of
  the process, we are ensuring that any configuration items
  specifically set in the configuration files overrides user
  settings. This occurs since /most/ of the configuration settings use
  =custom-set-variables=, which would override any customization done
  by the user during a previous session. This allows some
  experimentation through the =customize= interface which would be
  sanitized on the next run. This does not serve to clean out any
  customizations which are not explicitly covered in configuration
  files.

  #+BEGIN_SRC emacs-lisp
    (load custom-file)
  #+END_SRC

** Shell

   I try to use my shell within Emacs as much as possible. I will admit
   that I have not yet been able to do this completely, though the desire
   is there.

*** eshell

    Additional references:

    - [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][Mikey Petersen's Mastering Eshell]]
    - [[http://www.modernemacs.com/post/custom-eshell/][Modern Emacs: Making eshell your own]]
    - [[https://www.emacswiki.org/emacs/EshellPrompt][EmacsWiki: EshellPrompt]]
    - [[http://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/][Liang Zan: Customozing Your Emacs Eshell Propmpt]]

    Packages:

    - [[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]]
    - [[https://github.com/kaihaosw/eshell-prompt-extras][eshell-prompt-extras]]

**** Prompt

     #+BEGIN_SRC emacs-lisp
       (use-package eshell-git-prompt
         :ensure t
         :config
         (eshell-git-prompt-use-theme 'powerline))
     #+END_SRC


**** Configuration

***** Control files

      #+BEGIN_SRC emacs-lisp
        (custom-set-variables '(eshell-directory-name (concat metafiles-dir "/eshell/")))
      #+END_SRC

***** Visual Commands

      Eshell has support for special handling of commands which present their
      output in a visual fashion (see help for =eshell-visual-commands=).

      Typically, these are commands which require a proper terminal
      environment to run in. =eshell= will run them in a term buffer when
      they are invoked.

      The emacs defaults are:

      - vi
      - screen
      - top
      - less
      - more
      - lynx
      - ncftp
      - pine
      - tin
      - trn
      - elm

      I don't use a lot of these commands and there are others I do use.

     #+BEGIN_SRC emacs-lisp
       (setq eshell-visual-commands
             '("less" "tmux" "top" "bash" "zsh"))
     #+END_SRC

      The =eshell-visual-subcommands= specifies an alist of subcommands which
      present their output visually, in much the same way as specified
      above. In this case, however, you can specify specific arguments which
      trigger the behavior.

      I find this to be especially useful for =git= commands which display
      tree information (like log). I have a number of aliases set up with git
      which I want to ensure are covered.

     #+BEGIN_SRC emacs-lisp
       (setq eshell-visual-subcommands
             '(("git"
                "diff" "df" "dc"
                "show"
                "log" "lg" "tree" "lol" "lola" "lala" "ltla" "ldla")))
     #+END_SRC

*** comint

    #+BEGIN_SRC emacs-lisp
      (use-package comint
        :bind (:map comint-mode-map
                    ("M-p" . comint-previous-matching-input-from-input)
                    ("M-n" . comint-next-matching-input-from-input)
                    ("C-M-n" . comint-next-input)
                    ("C-M-p" . comint-previous-input))
        :custom
        (comint-prompt-read-only t)
        :init
        (add-hook 'term-exec-hook
                  (function
                   (lambda ()
                     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix)))))
    #+END_SRC

*** Tramp

    Tramp is a fantastic package that allows for remote file editing. Make
    sure tramp uses ssh by default. Also make sure that files are stored in
    the meta information directory.

    #+BEGIN_SRC emacs-lisp
      (use-package tramp
        :custom
        (tramp-default-method "ssh")
        (tramp-persistency-file-name meta-tramp))
    #+END_SRC


* Custom Configuration
** Font

   #+BEGIN_SRC emacs-lisp
     (defun jme:set-font-scale (size)
       "Adjust the font scale used."
       (interactive "nWhat font size fo you want? ")
       (set-face-attribute 'mode-line nil :inherit 'default :height (+ 10 size))
       (eval-after-load "org"
         (set-face-attribute 'org-block nil :inherit 'fixed-pitch))
       (cond
        ((find-font (font-spec :family "Hack Mono"))
         (progn
           (set-face-attribute 'default nil :family "Hack Mono" :height size)
           (set-face-attribute 'fixed-pitch nul :family "Hack Mono" :inherit 'default)))
        ((find-font (font-spec :family "Noto Mono"))
         (progn
           (set-face-attribute 'default nil :family "Noto Mono" :weight 'light :height size)
           (set-face-attribute 'variable-pitch nil :family "Noto Mono" :inherit 'default)))))

     (defun jme:update-font-scale ()
       "Increase the font scale to handle HDPI issues on Pixelbook"
       (if window-system
           (jme:set-font-scale 160)))

     (add-hook 'window-setup-hook 'jme:update-font-scale)
   #+END_SRC

** Theme
*** Material
    #+BEGIN_SRC emacs-lisp
      (use-package material-theme
        :ensure t)
    #+END_SRC
*** Spaceline

    Configure spaceline for mode-line theme. I am overly specific in
    toggling the segments. As I work to improve the way my mode line works
    (which is a continuous effort), I find it best to be very specific about
    which features to turn on/off.

    #+BEGIN_SRC emacs-lisp
      (use-package spaceline
        :ensure t
        :config
        (use-package spaceline-all-the-icons
          :ensure t
          :config
          (progn
            (dolist (s '((jme:spaceline-read-only "#4271AE" "Read only buffer face.")
                         (jme:spaceline-modified "#F36C60" "Modified buffer face.")
                         (jme:spaceline-unmodified "#78909C" "Unmodified buffer face.")))
              (eval `(defface ,(nth 0 s)
                       `((t (:background ,(nth 1 s)
                                         :foreground "#3E3D31"
                                         :inherit 'mode-line)))
                       ,(nth 2 s)
                       :group 'spaceline)))

            (defun jme:spaceline-highlight-face-modified ()
              "Set the highlight face depending on the buffer modified status.
               Set `spaceline-highlight-face-func' to
               `spaceline-highlight-face-modified' to use this."
              (cond
               (buffer-read-only 'jme:spaceline-read-only)
               ((buffer-modified-p) 'jme:spaceline-modified)
               (t 'jme:spaceline-unmodified)))

            (setq-default spaceline-highlight-face-func 'jme:spaceline-highlight-face-modified)
            (setq-default spaceline-all-the-icons-separator-type 'cup)
            (spaceline-toggle-all-the-icons-modified-on)
            (spaceline-toggle-all-the-icons-bookmark-off)
            (spaceline-toggle-all-the-icons-dedicated-off)
            (spaceline-toggle-all-the-icons-window-number-off)
            (spaceline-toggle-all-the-icons-eyebrowse-workspace-off)
            (spaceline-toggle-all-the-icons-buffer-size-on)
            (spaceline-toggle-all-the-icons-projectile-on)
            (spaceline-toggle-all-the-icons-mode-icon-on)
            (spaceline-toggle-all-the-icons-buffer-id-on)
            (spaceline-toggle-all-the-icons-buffer-path-off)
            (spaceline-toggle-all-the-icons-process-off)
            (spaceline-toggle-all-the-icons-position-on)
            (spaceline-toggle-all-the-icons-region-info-on)
            (spaceline-toggle-all-the-icons-fullscreen-off)
            (spaceline-toggle-all-the-icons-text-scale-on)
            (spaceline-toggle-all-the-icons-multiple-cursors-off)
            (spaceline-toggle-all-the-icons-narrowed-on)
            (spaceline-toggle-all-the-icons-vc-icon-off)
            (spaceline-toggle-all-the-icons-vc-status-on)
            (spaceline-toggle-all-the-icons-git-status-off)
            (spaceline-toggle-all-the-icons-git-ahead-off)
            (spaceline-toggle-all-the-icons-flycheck-status-on)
            (spaceline-toggle-all-the-icons-flycheck-status-info-off)
            (spaceline-toggle-all-the-icons-package-updates-off)
            (spaceline-toggle-all-the-icons-org-clock-current-task-on)
            (spaceline-toggle-all-the-icons-hud-off)
            (spaceline-toggle-all-the-icons-buffer-position-off)
            (spaceline-toggle-all-the-icons-battery-status-on)
            (spaceline-toggle-all-the-icons-time-on)
            (spaceline-toggle-all-the-icons-which-function-on)
            (spaceline-toggle-all-the-icons-temperature-off)
            (spaceline-toggle-all-the-icons-weather-off)
            (spaceline-toggle-all-the-icons-minor-modes-off)
            (spaceline-toggle-all-the-icons-nyan-cat-off)
            (spaceline-all-the-icons-theme)
            (spaceline-all-the-icons--setup-paradox))))
    #+END_SRC


* Org Mode
** What I Use Org For

   Just about everything.

   Anything I write these days is written completely, or at least starts, in
   Org.

   I have recently started keeping day specific notes. Each day is
   represented by an individual Org file, referred to as a ~daypage~. The
   original mechanism I use for handling this is inspired by [[http://tomparslow.co.uk][Thomas
   Parslow's]] article [[http://almostobsolete.net/daypage.html][A day page for Org-Mode]].

** Configuration

   Inspired by the [[https://github.com/eschulte/emacs24-starter-kit][Emacs Starter Kit]], I set up my configuration file using
   Org-babel. My personal move to this literate style of configuration
   programming began with this file. My main configuration file loads this
   automatically by using =(org-babel-load-file "/path/to/file")=.

*** General settings
**** Modules

     Org has a number of handy optional modules. The following table lists
     the org modules which I have looked into at some point in time. This
     table serves as a reference for their functionality.

     | Name              | Description                                                        |
     |-------------------+--------------------------------------------------------------------|
     | org-annotate-file | Provides a means to annotate arbitraty files in a central location |
     | org-bbdb          | Allows linking to BBDB entries from within org                     |
     | org-bibtex        | Allows links to database entries in BibTeX files                   |
     | org-eshell        | Allows linking to an eshell and executing a command                |
     | org-eww           | Allows creating a link to URL of an eww buffer                     |
     | org-feed          | Allows entries to be created and changed by items in an RSS feed   |
     | org-git-link      | Allows linking to files in git repository                          |
     | org-panel         | A kind of control panel for org - facilitates quick navigation     |

     The default set of modules (as of 24.4) are:

     - org-w3m
     - org-bbdb
     - org-bibtex
     - org-docview
     - org-gnus
     - org-info
     - org-irc
     - org-mhe
     - org-rmail

     The following list are the set of modules that I am currently
     experimenting with.

     #+BEGIN_SRC emacs-lisp
       (setq org-modules '(org-annotate-file
                           org-bibtex
                           org-eww
                           org-list))
     #+END_SRC

**** Org Files

     I use a number of files to break up tasks into resonably grouped files.

     - =work.org= - Work-specific items, general projects (ones that do not
       have their own project structure).
     - =tasks.org= - General tasks, potentially re-filed.
     - =notes.org= - General notes file, doubles as journal if needed.
     - =calendar.org= - specific calendar items I want to show in my
       agenda. This does not contain my full calendar as I do not want my
       agenda views clouded by all the meetings I need to go to.

     Daypages have their own directory and the files are generated
     on-demand.

     #+BEGIN_SRC emacs-lisp
       (setq daypage-path (concat org-directory "/days/"))
       (setq diary-file (concat org-directory "/diary"))
       (setq org-agenda-files (list (concat org-directory "/work.org")
                                    (concat org-directory "/tasks.org")
                                    (concat org-directory "/notes.org")
                                    (concat org-directory "/calendar.org")))
       (setq org-default-notes-file (concat org-directory "/notes.org"))
       (setq org-annotate-file-storage-file (concat org-directory "/annotated.org"))
       (setq org-agenda-include-diary nil)
     #+END_SRC

*** Babel

    Ensure we have support for programming languages used in code blocks.

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (ditaa . t)
         (dot . t)
         (gnuplot . t)
         (plantuml . t)
         (python . t)
         (js . t)
         (lisp . t)
         (sh . t)
         (shell . t)))
    #+END_SRC

*** Look and Feel

    Use utf-8 bullets for nicer look.

    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :after org
        :ensure t
        :demand t
        :hook (org-mode . (lambda () (org-bullets-mode 1))))
    #+END_SRC

    =org-sticky-header= shows off-screen Org heading at top of window.

    #+BEGIN_SRC emacs-lisp
      (use-package org-sticky-header
        :after org
        :ensure t
        :demand t
        :hook (org-mode . org-sticky-header-mode)
        :config
        (setq org-sticky-header-full-path 'full))
    #+END_SRC

    Startup with content not folded.

    #+BEGIN_SRC emacs-lisp
      (setq org-startup-folded nil)
    #+END_SRC

    The following ensures that I do not accidentally make edits to invisible
    areas. A value of ~show~ causes the point to become visible and actually
    do the requested edit.

    #+BEGIN_SRC emacs-lisp
      (setq org-catch-invisible-edits 'smart)
    #+END_SRC

**** Code block fontification

     The following displays the contents of code blocks using the major-mode
     of the code.  It also changes the behavior of ~TAB~ to work as
     appropriate for the major-mode.  This allows for reading and writing
     code inside of Org to be closer to the experience in the major-mode
     itself.

     #+BEGIN_SRC emacs-lisp
       (setq
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
     #+END_SRC

**** Targets

     Targets include this file and any file contributing to the agenda - up
     to 5 levels deep.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-targets '((org-agenda-files . (:maxlevel . 5))))
     #+END_SRC

     Targets start with the file name. This allows creating level 1 tasks.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-use-outline-path 'file)
     #+END_SRC

     Targets complete in steps so we start with filename, TAB shows the next
     level of targets etc.

     #+BEGIN_SRC emacs-lisp
       (setq org-outline-path-complete-in-steps t)
     #+END_SRC

     Allow refile to create parent tasks with confirmation.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-allow-creating-parent-nodes 'confirm)
     #+END_SRC

*** Task settings

**** Timestamps

     Add a timestamp to the task when it moves to the DONE state.

     #+BEGIN_SRC emacs-lisp
       (setq org-log-done 'time
             org-log-into-drawer "LOGBOOK")
     #+END_SRC

**** Workflows

     Personal todo items are tracked with TODO, other tracked items are
     labeled with TASK. Inspired by [[http://juanreyero.com/article/emacs/org-teams.html][Org-mode tricks for team management]].

     #+BEGIN_SRC emacs-lisp
       (setq org-todo-keywords
             '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "STALLED(x@/!)" "|" "DONE(d!)" "CANCELLED(c@)")
               (sequence "TASK(f)" "|" "DONE(d!)")
               (sequence "MAYBE(m)" "|" "DONE(d!)" "CANCELLED(c@)")
               (sequence "RISK(r)" "|" "MITIGATED(i@)")))
     #+END_SRC

     Add some color to the different items to make them easier to visualize.

     #+BEGIN_SRC emacs-lisp
       (setq org-todo-keyword-faces
             '(("TODO" . (:foreground "DarkOrange" :weight bold))
               ("STARTED" . (:foreground "DarkOrange" :weight bold))
               ("WAITING" . (:foreground "gold" :weight bold))
               ("MAYBE" . (:foreground "spring green"))
               ("DONE" . (:foreground "dark sea green"))
               ("STALLED" . (:foreground "slate grey"))
               ("CANCELLED" . (:foreground "slate grey"))
               ("TASK" . (:foreground "DeepSkyBlue"))
               ("RISK" . (:foreground "white" :background "orange red"))
               ("MITIGATED" . (:foreground "white" :background "dark green"))))
     #+END_SRC

***** Projects

      Collections of tasks and other items are projects, and are marked with
      the =prj= tag. They should contain todo items and are considered stuck
      unless they do. The =prj= tag should not be inheritable, otherwise its
      tasks will also appear as projects.

      #+BEGIN_SRC emacs-lisp
        (setq org-tags-exclude-from-inheritance '("prj"))
      #+END_SRC

**** Templates

     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(("t" "Todo" entry (file+headline "tasks.org" "Tasks")
                "* TODO %^{Brief Description} %^g\n Added: %U\n\n  %?\n")
               ("T" "Quick task" entry (file+headline "tasks.org" "Tasks")
                "* TASK %^{Task}"
                :immediate-finish t)
               ("j" "Journal entry" plain (file+datetree "notes.org")
                "%K - %a\n%i\n%?\n"
                :unnarrowed t)
               ("J" "Journal entry with date" plain (file+datetree+prompt "notes.org")
                "%K - %a\n%i\n%?\n"
                :unnarrowed t)
               ("n" "Notes" entry (file+datetree "notes.org" "Inbox")
                "* %^{Description} %^g\n  Added: %U\n\n  %?\n")))
     #+END_SRC

**** Archiving

     Archiving of completed tasks. see
     http://article.gmane.org/gmane.emacs.orgmode/3629.

     Alternative implementations:
     - [[https://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command][How to archive all the DONE tasks using a single command]]

     To set an org file up for archiving you need to add the following at
     the top of the file (replace archive.text with the archive file):

     =-*- mode: org; after-save-hook: (archive-done-tasks) -*-=
     =#+ARCHIVE: archive.txt::* %s archive=

     #+BEGIN_SRC emacs-lisp
       (defvar jme:org-archive-expiry-days 7
         "The number of days after which a completed task should be auto-archived.
           This can be 0 for immediate, or a floating point value.")

       (defun jme:archive-p (p)
         "Determine if the headline at point P needs to be archived."
         (let* ((props (org-entry-properties p))
                (closed (assoc "CLOSED" props)))
           (if closed
               (let ((when-closed (org-parse-time-string (cdr closed))))
                 (if (>= (time-to-number-of-days (time-subtract (current-time)
                                                                (apply #'encode-time when-closed)))
                         jme:org-archive-expiry-days)
                     t)))))

       (defun jme:does-item-need-archive? ()
         "Does item at point need to be archived?"
         (interactive)
         (if (jme:archive-p (point))
             (message "Yes")
           (message "No")))

       (defun jme:org-archive-done-tasks ()
         (interactive)
         (save-excursion
           (goto-char (point-min))
           (let ((done-regexp
                  (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
                 (state-regexp
                  (concat "- State \"\\(" (regexp-opt org-done-keywords)
                          "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
             (while (re-search-forward done-regexp nil t)
               (let ((end (save-excursion
                            (outline-next-heading)
                            (point)))
                     begin)
                 (goto-char (line-beginning-position))
                 (setq begin (point))
                 (if (jme:archive-p begin)
                   (org-archive-subtree)
                  (goto-char end)))))
           (save-buffer)))

           (setq safe-local-variable-values (quote ((after-save-hook archive-done-tasks))))
           (defalias 'archive-done-tasks 'jme:org-archive-done-tasks)
     #+END_SRC

*** Agenda Settings

    Look ahead two days of my agenda at a time.

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-span 2)
    #+END_SRC

    A common problem with all-day and multi-day events in org agenda view is
    that they become separated from timed events and are placed below all
    =TODO= items. Likewise, additional fields such as =Location:= are
    orphaned from their parent events. The following hook will ensure that
    all events are correctly placed in the agenda:

    See http://orgmode.org/worg/org-contrib/org-mac-iCal.html

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-agenda-cleanup-fancy-diary-hook
                (lambda ()
                  (goto-char (point-min))
                  (save-excursion
                    (while (re-search-forward "^[a-z]" nil t)
                      (goto-char (match-beginning 0))
                      (insert "0:00-24:00")))
                  (while (re-search-forward "^ [a-z]" nil t)
                    (goto-char (match-beginning 0))
                    (save-excursion
                      (re-search-backward "^[0-9]+:[0-9]+-[0-9]+:[0-9]+ " nil t))
                    (insert (match-string 0)))))
    #+END_SRC

**** Allow quickly marking items as done in the agenda view. (From [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-82][here]]).

     #+BEGIN_SRC emacs-lisp
       (defun jme:org-agenda-done (&optional arg)
         "Mark current TODO as done.
       This changes the line at point, all other lines in the agenda referring to
       the same tree node, and the headline of the tree node in the org file."
         (interactive "P")
         (org-agenda-todo "DONE"))
       ;(bind-key "x" 'jme:org-agenda-done org-agenda-mode-map)

       (defun jme:org-agenda-done-and-add-followup ()
         "Mark the current TODO as done and add another task after it.
       Creates it at the same level as the previous task."
         (interactive)
         (org-agenda-todo "DONE")
         (org-agenda-switch-to)
         (org-capture 0 "t"))
       ;(bind-key "X" 'jme:org-agenda-done-and-add-followup org-agenda-mode-map)
     #+END_SRC

*** Clocking

    I have recently been trying to train myself to use org clocking as a
    means of improving my task efficiency. My configuration here is probably
    pretty light and not comprehensive. I expect, like everything else, it
    will evolve over time.

**** Configuration

     Make sure clock history, as well as any running clocks, are preserved
     across emacs sessions. Perserving the clock is a necessity for me as I
     often have time when I need to restart Emacs while working on some
     task.

     =org-clock-in-resume= ensures that when clocking into a task with an
     open clock, the clock is resumed.

     Make sure =org-clock-persist-query-resume= is nil, so that there is no
     prompt when attempting to resume a clock. Just resume it.

     #+BEGIN_SRC emacs-lisp
       (org-clock-persistence-insinuate)
       (setq org-clock-persist t)
       (setq org-clock-in-resume t)
       (setq org-clock-perist-query-resume nil)
     #+END_SRC

     Set up some pre-sets for Effort.

     #+BEGIN_SRC emacs-lisp
       (setq org-global-properties
             '(("Effort_ALL" .
                "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")))
     #+END_SRC

     =org-columns= provides a nice overview of tasks in the buffer. Set the
     default format to include effort and clock summary.

     #+BEGIN_SRC emacs-lisp
       (setq org-columns-default-format "%50ITEM(Task) %TODO %2PRIORITY %10Effort(Effort){:} %10CLOCKSUM %TAGS")
     #+END_SRC

*** LaTeX

    Use smart quotes when exporting.

    #+BEGIN_SRC emacs-lisp
      (setq org-export-with-smart-quotes t)
    #+END_SRC

**** Source code listings

     Use the ~minted~ package for source code fontification and coloring.

     #+BEGIN_SRC emacs-lisp
       (add-to-list 'org-latex-packages-alist '("" "minted"))
       (setq org-latex-listings 'minted)
       (setq org-latex-minted-options
          '(("frame" "lines")
            ("fontsize" "\\scriptsize")))
     #+END_SRC

     We need to also ensure that the PDF conversion process adds the
     =-shell-escape= option to pdflatex.

     #+BEGIN_SRC emacs-lisp
       (setq org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
     #+END_SRC

     Add custom document classes.

     #+BEGIN_SRC emacs-lisp
       (require 'ox-latex)
       (add-to-list 'org-latex-classes
             '("mezeoorgdoc" "\\documentclass[10pt,oneside]{mezeoorgdoc}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagrah*{%s}")))
       (add-to-list 'org-latex-classes
             '("jmeorgdoc" "\\documentclass[10pt,oneside]{jmeorgdoc}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagrah*{%s}")))
       (add-to-list 'org-latex-classes
             '("jmeorgarticle" "\\documentclass[10pt,oneside,article]{jmeorgdoc}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagrah*{%s}")))
       (add-to-list 'org-latex-classes
              '("synacororgarticle" "\\documentclass[10pt,oneside,article]{synacororgarticle}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagrah*{%s}")))
     #+END_SRC

*** Key bindings

**** Org specific keybindings

     Bind keys specific to org-mode. I try to train myself in using the
     default keybindings. This helps to ensure that I handle things more
     easily as they naturally evolve with the org package. However, there
     are some functions I use regularly which have no keybindings. These
     bindings need to be watched with a careful eye as they may end up
     overriding something in the future.

     I use timestamps quite frequently in my logging/journaling and many
     times I want an /inactive/ timestamp (=org-time-stamp-inactive=)
     instead of an /active/ (=org-time-stamp=) one. It is easy enough to
     toggle them with =org-toggle-timestamp-type=, but that has no
     keybinding either. I bound =org-time-stamp-inactive= to =C-c t= since
     it was unbound and =t= is a good representation for /time/.

     #+BEGIN_SRC emacs-lisp
       (bind-key "C-c t" 'org-time-stamp-inactive org-mode-map)
     #+END_SRC

**** Org global keybindings

     Bind keys which should be available in the global keymap which support
     org-mode functions.

    #+BEGIN_SRC emacs-lisp
      (bind-key "C-c l" 'org-store-link)
      (bind-key "C-c L" 'org-insert-link-global)
      (bind-key "C-c a" 'org-agenda)
      (bind-key "C-c c" 'org-capture)
      (bind-key "C-c b" 'org-iswitchb)
    #+END_SRC


* Footer

  Add in the expected Emacs module footer.

  #+BEGIN_SRC emacs-lisp
    (provide 'init-ext.el)
    ;;; init-ext.el ends here
  #+END_SRC
